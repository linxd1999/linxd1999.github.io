---
title: 进程管理
tags: OS
---

### 一、进程和线程

#### 1、进程

- 进程(Process)：一个具有独立功能的程序关于一个数据集合上的一次动态执行过程

- 进程的组成：代码段、程序处理的数据、程序计数器(指示下一条将运行的指令)、系统资源

- 进程的特点：

  > 1、动态性：进程是进程实体的一次执行过程
  >
  > 2、并发性：多个进程同时存在于内存中并能在一段时间内同时运行
  >
  > 3、独立性：在传统OS中，进程是一个能独立运行、分配资源、调度的基本调度
  >
  > 4、异步性：进程按各自独立、不可预知的速度向前推进

- 进程控制块(PCB)：每个进程用来保存与该进程有关的各种状态信息，是进程存在的唯一标识

- 进程的状态：创建、运行、等待(阻塞)、就绪、结束

![1](D:\blog\source\_posts\新建文件夹\1.jpg)



> 1、进程只能自己阻塞自己，只有自己知道自己什么时候需要等待事件发生
>
> 2、阻塞态不能直接转换成运行态
>
> 3、挂起态：进程没有占有内存空间，处于挂起态的进程映像在磁盘上

- 上下文切换：OS内核将旧进程的关联状态保存在其PCB中，然后装入经调度之后准备执行的新进程的已保存的关联状态

<!--more-->

#### 2、线程

- 线程(Thread)：OS中能进行调度的最小单位，包含在进程之中，是进程中的实际运作单位

- 线程的组成：线程id、程序计数器、各种寄存器、栈

- 线程的特点：和属于同一进程的其他线程共享代码段、数据段和其他OS资源

  例如：浏览器这个进程可分为很多页面线程，不同页面可以做不同的事情

- 线程的优点：

  > 1、响应度高：部分线程阻塞或操作时间冗长，该程序仍然能执行下去，增加对用户的响应程度
  >
  > 2、资源共享：允许一个进程在同一个地址空间有多个活动的线程
  >
  > 3、经济：进程创建所需的内存和资源分配昂贵，而线程则相对经济
  >
  > 4、适合多处理器结构：单线程进程只能运行在一个CPU上，在多CPU上使用多线程加强了OS的并发能力

- 进程、线程的区别：

  > 1、调度性：在传统OS中，拥有资源和独立调度分配的基本单位都是进程；在引入线程的OS中，线程是调度分配的基本单位，而进程是资源分配的基本单位
  >
  > 2、并发性：在引入线程的OS中，进程之间可以并发执行，同一进程的线程之间也可以并发执行，从而使OS有更好的并发性
  >
  > 3、拥有资源：进程拥有自己的资源，线程一般不拥有资源，但可以访问其所在进程的资源
  >
  > 4、系统开销：创建、撤销进程涉及系统资源的分配与回收，需要比线程的创建和撤销大得多的系统开销，进程切换的开销也远大于线程

### 二、进程调度(dispatch)

#### 1、调度层次

- 长期调度/高级调度/作业调度：把进程从磁盘中首次调入内存，只有进程离开系统时，才需要长期调度程序的调度。必定发生，但频率比较低。
- 中期调度/中级调度/内存调度：在分时操作系统中，将进程从内存调入磁盘，从而减少内存中的进程数据。之后需要时再重新调入内存，并从中断处继续执行。可能发生，频率中等。
- 短期调度/低级调度/进程调度：从就绪态中选择进程分配CPU，必定发生，且频率很高。

#### 2、调度准则

- CPU使用率：需要让CPU尽可能忙
- 吞吐量：单位时间内完成的进程数量
- 周转时间：从进程提交到进程完成所用的时间
- 等待时间：进程在就绪队列中等待所花费的时间之和
- 响应时间：从提交请求到产生第一响应的时间

#### 3、调度算法

##### 1、先来先服务算法(FCFS)

例：银行排队、打印机

方式：非抢占

调度时机：一个进程结束

特点：利于长进程，不利于短进程；利于CPU繁忙的作业，不利于IO繁忙的作业；不适用于分时，实时系统

##### 2、 短作业优先调度算法(SJF)

思想：优先对短作业或短进程进行处理的算法，如果两个进程长度相同，可用FCFS处理(插队+动态改变)

方式：非抢占 / 抢占(最短剩余时间优先调度)

调度时机：程序结束时 / 阻塞I/O时

特点：利于短进程，不利于长进程(饥饿)；不能保证紧迫作业及试运行(程序员可能提供虚假时间)；平均等待时间，平均周转时间最少；吞吐量很大(单位时间内运行的进程数多)

##### 3、高优先级调度算法

思想：优先对高优先级的进程进行处理

方式：抢占 / 非抢占

调度时机：程序结束时 / I/O阻塞时 / 更高优先级进程进入队列时

特点：满足紧迫作业需求；适用于实时系统；优先级分为动态优先级和静态优先级

##### 4、轮转法调度算法(RR)

思想：分时间片使各进程轮流获取CPU(10ms-100ms)

方式：抢占

调度时机：时间片用完 / 程序结束

特点：时间片大小讲究，太大退化为FCFS，太小上下文切换次数很多，开销大；适用于分时系统

##### 5、高响应比优先算法

响应比Rp = (等待时间+服务时间) / 服务时间

思想：优先选择响应比高的作业(从外存放到内存的过程中，包含的一个或多个进程)

方式：无(主要用于作业调度)

调度时机：无

特点：FCFS与SJF的平衡；克服饥饿，既能兼顾长作业，又能让短作业先运行

##### 6、多级反馈队列算法

思想：FCFS(每个窗口都排队)+优先级(每个窗口都有优先级)+时间片轮转(时间片成倍增加，最后一个窗口循环轮转)，多级反馈队列不必事先知道各种进程所需的执行时间，还可以满足各种类型的进程需要。

方式：综合

调度时机：综合

特点：短作业优先带来的等待时间降低，周转时间降低；长作业能得到处理

### 三、同步与互斥

#### 1、相关概念

- 临界资源：一次仅允许一个进程使用的资源(打印机，网卡，键盘，共享变量)
- 临界区：每个进程中访问临界资源的那段代码
- 信号量(semaphore)：用来保证两个或多个临界区代码不被并发调用
- 互斥：两个或以上进程，不同时进入关于同一组共享变量的临界区，否则可能发生时间相关的错误
- 同步：在多道程序环境下，进程并发执行，进程因相互协作完成某个操作的次序关系
- PV操作：控制信号量的一组原子操作，P是等待(减法，检测，阻塞)，V是释放(加法，检测，唤醒)

#### 2、实现互斥的方法

##### 1、硬件实现法

- 中断屏蔽法：进程切换大多源于中断，若没有切换，也就不需要互斥，所以屏蔽中断即可实现互斥

- 原子硬件指令法：TestAndSet、Swap

  ![](D:\blog\source\_posts\新建文件夹\2.png)

  ![3](D:\blog\source\_posts\新建文件夹\3.png)

##### 2、软件实现法

- 单标志法

  思想：一个进程的进入临界区权限只能被另外一个进程赋予，但两个进程必须交替进入临界区，如果某个进程不进入临界区，那么另外一个进程也无法进入临界区，造成资源浪费

  ![4](D:\blog\source\_posts\新建文件夹\4.png)

- 双标志先检查法

  思想：一个进程进入临界区之前先查看临界区资源是否被访问，若没有被访问，则把自身标志位设置为true，若被访问则等待

  ![5](D:\blog\source\_posts\新建文件夹\5.png)

- 双标志后检查法

  思想：防止先检查法的同时进入临界区问题，先上锁，后检查(会因为两个进程因为争夺临界区过于强势导致没有一个进程能获取临界区资源，导致饥饿)

  ![6](D:\blog\source\_posts\新建文件夹\6.png)

- Peterson算法

  思想："孔融让梨"的思想，虽然表示自己也想获取临界区资源，但主动询问对方是否想访问，若对方想访问临界区资源且自己谦让了，对方进入临界区

  ![7](D:\blog\source\_posts\新建文件夹\7.png)

#### 3、信号量的使用

伪代码：

![8](D:\blog\source\_posts\新建文件夹\8.png)

> 若s.value>0，则临界区资源可以被获取
>
> 若s.value<=0，则临界区满，需要排队获取
>
> 实现互斥：s.value=1
>
> 实现同步：s.value=0

##### 1、 生产者与消费者问题

特征：容器内的物品数量<=容量

分析：生产者关注剩余空间(emtpy)；消费者关注已占有空间(full)；互斥信号量mutex(用于影响容器大小的语句两端)

有几个容器就需要几个互斥信号量mutex

##### 2、读者与写者问题

特征：资源是否被占用；写者可写文件，但读者只能访问

例：有读写两组进程共享一个文件，多个读者可同时访问文件，多个写者不能同时访问文件，读者和写者不能同时访问文件

![9](D:\blog\source\_posts\新建文件夹\9.png)

### 四、死锁

#### 1、相关概念

- 死锁：两个或两个以上的进程(或线程)在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都无法推进下去
- 活锁：两个线程，都很谦让，最后导致两个线程都无法获取资源
- 饥饿：某个进程因为其他进程轮流占用CPU导致它很久无法占用CPU的情况
- 死锁产生原因：
  - 应用程序层面：信号量使用不当
  - OS内核程序层面：不可抢占软硬件资源(多进程对有限不可抢占资源的竞争，进程申请资源的推进顺序不合理

- 死锁产生的必要条件
  - 互斥条件：必须有临界资源
  - 占有并等待：一个进程必须占有一个资源，并等待另一资源，而该资源为其他进程所占有
  - 非抢占：资源不能被抢占
  - 循环等待：一组等待进程，每个进程所请求的资源都被另一个进程所占有

- 处理死锁的策略：预防死锁，避免死锁，检测与解除死锁
- 预防死锁：通过扼杀其产生的必要条件
  - 互斥：几乎行不通
  - 不可抢占：强行抢占某资源
  - 占有并等待：一次性把资源申请完
  - 循环等待：顺序资源分配法

- 死锁避免：银行家算法(规划合理的资源申请顺序，安全序列)


{"meta":{"title":"L","subtitle":null,"description":"站在巨人的肩上","author":"linxd","url":"https://linxd1999.github.io","root":"/"},"pages":[{"title":"标签","date":"2019-05-28T09:46:12.000Z","updated":"2019-05-28T11:27:07.487Z","comments":true,"path":"tags/index.html","permalink":"https://linxd1999.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Git & Github","slug":"Git","date":"2019-11-28T13:11:58.817Z","updated":"2019-11-28T13:11:58.817Z","comments":true,"path":"2019/11/28/Git/","link":"","permalink":"https://linxd1999.github.io/2019/11/28/Git/","excerpt":"","text":"一.Git基本概念1.版本控制系统 Git是开源的分布式版本控制系统，可以处理项目的版本控制 功能 协同修改：多人并行修改服务器端的同一个文件 权限控制：开发团队内外的人员拥有不同的权限 历史记录：查看修改人，修改时间，修改内容等 数据备份：保存当前状态，还保存每一个提交过的历史状态 分支操作：多条生产线同时推进任务 优势 在本地完成操作，不需要联网 尽可能添加数据而不是删改数据 数据完整性的保证(哈希算法) 2.Git结构 工作区：写代码的区域 暂存区：写完但还没有提交的命令(临时存储) 本地库：储存历史的版本 3.本地库和远程库 远程库位于代码托管中心 团队内部协作：远程库的控制者把本地库推送到远程库，然后团队开发人员可以clone该远程库到自己的本地库，然后修改后再推送到远程库 跨团队协作：团队外的人可以fork别人的远程库，然后在本地修改之后，再推送到远程库中，通过提交pull request请求，经审核通过后合并到别人的远程库中 二.Git命令行操作1.本地库初始化 命令：git init 在Git终端中，进入目录使用该命令，即可初始化一个本地库 .git目录是隐藏目录，存放的是本地库相关的子目录和文件，不能删除和胡乱修改 2.设置签名 作用：区分不同开发人员的身份 这里设置的签名和登录远程库的账号密码没有关系 项目级别/仓库级别：仅在当前本地仓库范围内有效 git config user.name abc git config user.email abc@qq.com 信息保存位置：./.git/config(cat .git/config) 系统用户级别：登录当前操作系统的用户范围 git config –global user.name abc git config –global user.email abc@qq.com 信息保存位置：~/.gitconfig(cat ~/.gitconfig) 两者必须有一个，但项目级别优先级更高 3.基本操作 状态查看：git status(查看工作区，暂存区状态) 添加：git add [file name] (将工作区的”新建/修改”添加到暂存区) 提交：git commit -m “commit message” [file name] (将暂存区中的内容提交到本地库) 查看历史记录： git log：显示具体信息(多屏显示，space向下翻页，b向上翻页，q退出) git log –pretty=oneline：单行显示 git log –oneline：简化单行显示 git reflog：HEAD@{移动到当前版本需要多少步} 版本前进后退 索引值：git reset –hard [局部索引值] ^符号(只能后退)：git reset –hard HEAD^ (一个^表示后退一步，n个表示后退n行) ~符号(只能后退)：git reset –hard HEAD~n(表示后退n步) reset参数： soft：只更改head指针的位置，暂存区和工作区不变，工作区内容不会丢失 mixed：默认参数，让暂存区和本地库一致，但工作区内容不会丢失 hard：head指针，暂存区，工作区三者一致，指针指向版本后做的更新全部丢失 找回删除文件：只要commit之后就会有记录，用reflog能看到所有修改的记录 git reset –hard [指针位置] 可以找回一切提交过的记录版本 删除操作还没提交到本地库，指针位置用HEAD 比较文件差异：如果git status中working tree clean，则没有输出 git diff [文件名]：工作区的文件与暂存区的文件相比较 git diff [本地库中历史版本] [文件名] ：工作区的文件和本地库历史记录比较 不指定文件名可以比较所有文件：git diff HEAD 4.分支管理 分支：多条线并行推进任务，以免影响主线开发 优点：提升开发效率；如果一个分支开发失败，不会对主线造成任何影响，删除重新开始即可 创建分支：git branch [分支名] 查看分支：git branch -v 切换分支：git checkout [分支名] 合并分支： 切换到需要被修改的分支git checkout [被合并的分支] 合并git merge [有新内容的分支名] 解决冲突： 冲突：不同分支在同一个位置进行修改 1.编辑文件，删除特殊符号 2.保存文件 3.git add [文件名] 4.git commit -m “日志信息” (不能带文件名) 合并操作需要在提交到本地库(commit)之后才能合并 三.Git基本原理1.哈希算法 哈希函数(散列函数)：把任意长度的输入通过散列算法转换成相同长度的输出，散列值的空间远小于原输入的空间 特点 输出长度固定 输入数据确定，则输出数据保持不变 输入数据变化，则输出数据会有很大变化 不同的输入可能有相同输出，所以哈希算法不可逆 Git底层用的是SHA-1算法来保证数据的完整性 2.Git保存版本的机制 Git把数据看作小型文件系统的一组快照，每次提交更新时Git会对当前全部文件制作一个快照并保存快照的索引。 如果文件没有修改，则不会重新存储该文件，而是保留一个指向之前储存的文件。 快照的理解：当你删除一个文件后，文件原来所占的磁盘空间并不是被清空，而是被文件系统标记为“已废弃，可修改”的状态，快照的作用就相当于将旧文件所占的空间保留下来，并且保存一个引用，而新文件中会继续使用与旧文件内容相同部分的磁盘空间，不同部分则写入新的磁盘空间 Git的数据文件管理和分支管理都用的是指针操作，效率高 四.Github1.创建远程库地址别名 查看当前所有远程地址别名：git remote -v 创建远程地址别名：git remote add [别名] [远程地址] 2.推送 git push [别名] [分支名] 3.克隆 git clone [远程地址] 效果 完整的把远程库下载到本地 创建远程地址别名 初始化本地库 4.团队成员邀请 Settings-Collaborators-Add collaborator(输入账号)-Copy invite link发送给对方-对方打开链接接收邀请-加入团队成功 5.拉取 pull=fetch+merge git fetch [远程库地址别名] [远程分支名] git merge [远程库地址别名/远程分支名] git pull [远程库地址别名] [远程分支名]","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://linxd1999.github.io/tags/Git/"}]},{"title":"Css","slug":"CSS","date":"2019-11-25T15:18:11.690Z","updated":"2019-11-25T15:18:11.655Z","comments":true,"path":"2019/11/25/CSS/","link":"","permalink":"https://linxd1999.github.io/2019/11/25/CSS/","excerpt":"","text":"一.CSS 层叠样式表(Cascading Style Sheets) 可为网页的多层结构创建样式表，从而装饰网页 层叠意味着网页是分层结构，层次高的覆盖层次低的 二.样式表1.内联样式表 可将css样式写到元素的style属性中，只对当前元素起作用，不方便复用和后期维护 2.内部样式表 将style标签写到head标签中，可改变该文件中的样式，但不方便应用于多个文件 3.外部样式表 将样式表写到一个单独的.css文件中，如果某个文件要使用css样式，需要link标签引用 1&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"&gt; 完全使结构和表现分离，使样式表可在不同页面中使用，最大限度的复用了样式表，可以利用浏览器的缓存，加快用户访问速度，提高用户体验。 开发中最推荐使用外部css文件 在CSS中，祖先元素上的样式，会被后代元素所继承，利用继承可把一些基本的样式设置给祖先元素，这样所有的后代元素都将会自动继承这些样式 但不是所有样式都会被继承，背景相关，边框相关，定位相关的样式都不会被继承，否则会带来样式混乱的后果 三.语法1.注释 /**/ 2.选择器 选中页面中指定的元素，并且将声明块中样式应用到选择器对应的元素上 1.元素选择器 可以选择某种单独的元素设置样式 2.id选择器 对某个元素设置id属性，可以做到选中某种元素中带id的元素，用#标识 不建议用复合选择器 3.类选择器 对某个元素设置class属性，可以把几个元素分为一组来设置样式，用.标识 4.并集选择器 对几个选择器进行合并，可以同时操作更多不同的标签，用” , “分开 5.交集选择器 可以选中同时满足多个选择器的元素设置样式 6.通配选择器 可以选中页面内的所有元素，用” * “标识 7.后代选择器 语法：祖先元素 后代元素{ } 可选中某个特定祖先元素的某后代元素 8.子元素选择器 语法：父元素&gt;子元素 可选中指定父元素的子元素 9.伪类选择器 用来表示元素的一种特殊的状态 例如：访问过的超链接，获取焦点的文本框 链接样式：a:link(正常链接)，a:visited(访问过的链接)，a:hovor(鼠标滑过的链接)，a:active(正在点击的链接) hover和active也可以为其他元素设置样式 其他伪类选择器：input:focus(获取焦点)，p::selection(选中文本) 123456789101112131415a:link&#123; color: red; &#125; a:visited&#123; color: yellow; &#125; a:hover&#123; color: aqua; &#125; a:active&#123; color: black; &#125; p:active&#123; color: red; &#125; link，visited，hover，active优先级相同，但有顺序的区别。hover如果放active后面，则active被覆盖而失效，link，visited也必须放在hover，active前面，原因同理。 10.伪元素 CSS 在渲染文档的时候，伪元素可以通过 css 给 HTML 添加一个元素（叫标签也行），这个元素在文档树中是找不到的。 常见的有 :before(表示元素最前边的部分)，:after(表示元素最后边的部分)，:first-letter(选中第一个字母)，:first-line(选中元素的第一行) 11.属性选择器 title属性：这个标签可以给任何标签指定，当鼠标移到元素上时，title属性的值将会作为提示文字显示 作用：可以根据元素中的属性或属性值来选取指定元素 语法： [属性名] 选取含有指定属性的元素 [属性名=”属性值”] 选取含有指定属性值的属性 [属性名^=”属性值”] 选取以属性值以指定内容开头的元素 [属性名$=”属性值”] 选取以属性值以指定内容结尾的元素 [属性名*=”属性值”] 选取以属性值包含指定内容的元素 12.子元素的伪类 :first-child：选中第一个子元素 :last-child：选中最后一个子元素 :nth-child：选中任意位置的子元素，该选择器后面可以指定一个参数，指定要选中第几个子元素 even表示偶数位置的子元素 odd表示奇数位置的子元素 first-of-type，last-of-type，nth-of-type和上面三个非常类似，只不过child是在所有子元素里排列，type是在当前类型的子元素中排列 13.兄弟元素选择器 span+p：选中span后一个紧挨着的p元素 span~p：选中span后所有的p元素 14.否定伪类 可以从已选中的元素中剔除某些元素 语法：:not(选择器) 15.选择器的优先级 不同选择器选中同一个元素并且设置相同样式时，优先级高的选择器优先设置样式 规则： 内联样式：优先级1000 id选择器：优先级100 类和伪类：优先级10 元素选择器：优先级1 通配选择器：优先级0 继承的样式：无优先级 选择器中包含多个选择器时(交集选择器)，优先级相加再比较，但是和不会超过他的最大数量级 如果选择器优先级一样，则使用靠后的样式(覆盖) 并集选择器的优先级单独计算 样式最后可添加 !important，此时该样式的优先级会超越内联样式，但尽量避免使用 3.声明块 声明块紧跟选择器后边，用一对{}括起来 实际上就是名值对结构，一个声明块中可写多个声明，声明之间用;隔开，名值之间用:隔开 四.块元素和内联元素1.块元素 会独占一行的元素，无论内容多少，都会占一行 块元素主要用来对页面做布局 div元素：没有任何语义，是一个纯粹的块元素，不会为里面的内容设置任何默认样式 div元素主要用来对页面进行布局 a元素可以包含任何元素，但不能包含本身 p元素不可以包含任何其他的块元素 2.内联元素(行内元素) 不会占用一整行，只会占用自身大小 内联元素主要用来选中文本设置样式 span元素：本身没有任何语义，用来选中文字来设置样式 一般用块元素包含内联元素 五.文本1.文本标签 cite标签：参考的内容，如书名，歌名，话剧名，电影名等 small标签：内容比父元素中的文字小一些 p标签：短引用，内联引用 blockquote：长引用，块引用 sup标签：设置上标(superscript) sub标签：设置下标(subscript) del标签：删除的内容(划掉) ins标签：插入的内容(下划线) code标签：专门表示代码 pre标签：预格式标签，会将代码中的格式保存，不会忽略空格(一般结合pre和code表示一段代码) ul标签：无序列表 ol标签：有序列表 li标签：列表项 有序无序列表都可以改type属性来修改项目符号，但一般不使用，可用为li设置背景图片的方法来设置 ul，ol，li都是块元素 可互相嵌套 dl标签：定义列表，子标签dt：被定义的内容；dd：对定义内容的描述 2.文本样式 text-transform：设置文本大小写 none：默认值 capitalize：单词首字母大写，通过空格来识别单词 uppercase：所有字母大写 lowercase：所有字母小写 text-decoration：设置文本的修饰 none：默认值 underline：下划线 overline：上划线 line-through：删除线 超链接默认添加下划线，也就是text-decoration默认值为underline letter-spacing：字符间距 word-spacing：单词间距 text-align：设置文本对齐 left：靠左对齐 right：靠右对齐 center：居中对齐 justify：两端对齐(调整文本之间的空格) text-indent：设置首行缩进 指定一个正值时，会自动向右缩进指定的像素；指定一个负值，向左移动指定的像素，可以将一些不想显示的文字隐藏起来。 text-indent: 2em表示首行缩进两个字符，会根据字体大小变化而变化。 六.长度单位 像素px(pixel)：使用最多的单位，一个像素相当于屏幕上的一个小点，但这些像素点是不能被直接看见的。不同显示器的一个像素大小不同，显示效果越好，像素就越小。 百分比%：浏览器会根据父元素的样式来计算该值。好处在于父元素属性值变化时，子元素会随之改变，在创建自适应页面时，常使用百分比作为单位 em：和百分比类似，是相对于当前元素的字体大小来计算的，1em=1font-size(当前元素的字体大小)。使用em时，当字体大小发生改变时，em也会随之改变，当设置字体相关样式时会经常使用em 七.颜色单位 可直接用颜色的单词来表示不同的颜色 可用RGB值来表示不同的颜色 Red，Green，Blue三原色，通过三种颜色的不同浓度来表示不同的颜色 rgb(红色的浓度，绿色的浓度，蓝色的浓度) 颜色的浓度是一个0-255之间的值，255表示最大，0表示没有，也可用百分比 可用十六进制的rgb值来表示颜色，原理同上 语法：#红色绿色蓝色 00表示没有，ff表示255 两位重复数字可简写成一个数字 八.字体 color：字体颜色 font-size：设置的并不是字体大小，在页面中，每个文字都处于一个看不见的框中，font-size实际上设置的是格子的高度。一般情况下文字都要比格小一些，有时候也会比格大。根据字体的不同，显示效果也不同 font-family：指定文字字体 浏览器支持则使用，不支持则使用默认字体 可同时指定多个字体，用逗号分隔，优先使用前面的字体，如果没有或设置不了再尝试下一个 字体分为5大类：serif(衬线字体)，sans-serif(非衬线字体)，monospace(等宽字体)，cursive(草书)，fantasy(虚幻字体)，前两个很长用，一般放设置字体的最后兜底 font-style：可用来设置文字斜体 normal：文字正常 italic：文字斜体显示 oblique：文字倾斜，效果和italic一样，一般用italic font-weight：可显示文字的加粗效果 normal：正常粗细 bold：文字加粗显示 font-variant：设置小型大写字母 normal：正常字体 small-caps：小型大写字母 font：可同时设置字体相关的所有样式，用空格分开 斜体，加粗，小大字母，没有顺序要求，可写可不写，不写使用默认值 文字的大小和字体必须写，而且字体必须是最后一个样式，大小必须是倒数第二个样式 性能较好 九.行高 line-height：间接设置行间距，行间距=行高-字体大小 接收值： 直接接收一个大小 指定一个百分数，会相对字体去计算 接收一个数，则行高会设置字体大小相应的倍数 对于单行文本来说，可以将行高设置成和父元素一致，可以使单行文本在父元素中垂直居中 在font属性中可以指定行高，在字体大小后可以添加 / 行高，来指定行高，该值可选，如果不指定则会使用默认值 12345p&#123; /*前一行不生效，行高被后一行的默认值覆盖*/ line-height: 40px; font: 30px \"微软雅黑\"; &#125; 十.背景 background-image：设置背景图片 语法：background-image：url(“相对路径”) 如果背景图片大于元素，默认会显示图片的左上角 如果背景图片和元素一样大，则会将背景图片全部显示 如果背景图片小于元素，则平铺图片充满元素 一般设置背景图片时都会同时指定一个背景颜色 background-repeat：设置背景图片的重复方式 repeat：默认值，背景图片平铺 no-repeat：背景图片不会重复 repeat-x：背景图片沿水平方向重复 repeat-y：背景图片沿竖直方向重复 background-position：背景图片默认贴着左上角，这个属性可以调整图片在元素中的位置 该属性可以使用top，left，right，bottom，center中的两个值来指定位置 top left：左上，默认 bottom right：右下 缺省值会被指定为center 也可以指定两个偏移量：xpos，ypos，正数向右(下)移动，负数向左(上)移动 background-attachment：设置图片是否随页面一起滚动 scroll：默认值，背景图片会随着窗口滚动 fixed：背景图片会固定在某一个位置，不随页面滚动，一般都是设置body中的大图片；设置在块元素中的图片也不会随页面滚动，但是块元素会随着页面滚动，所以会出现擦黑板一样的效果(背景图片的定位永远相对于浏览器的窗口)，所以不随窗口滚动的图片一般设置给body，而不设置给其他元素。 background：设置所有的背景图片属性 没有顺序和数量的要求 没写的样式就使用默认样式，注意覆盖 十一.CSS-sprite 用不同图片表示一个按钮的不同状态时，第一次切换图片时，会发现有个非常快的闪烁，会造成一次不良的用户体验 产生原因：背景图片是以外部资源的形式加载进网页的，浏览器每加载一个外部资源就需要单独发送一次http请求；外部资源并不是同时加载，浏览器会在资源被使用的时候才去加载外部资源，由于加载图片需要一定的时间，所以在加载和显示的过程中有一段时间，背景图片无法显示，所以才会出现闪烁的情况 解决方法：可以将多张图片整合为一张图片，这样可以几张图片一起加载，就不会产生闪烁的问题了；然后通过background-position来切换要显示的图片位置，这种技术叫做图片整合技术(CSS-sprite，精灵图，雪碧图) 优点 浏览器只要发送一次加载请求就可以同时加载多个图片，提高请求的速度，增加用户体验 多张图片整合成一张，减少图片的总大小，提高请求的速度 十二.表格1.表格标签 使用table标签创建表格 tr创建表格中的一行，在tr中用td创建单元格 th创建表格的头部，有默认加粗和居中的样式，是一种特殊的td rowspan用来设置纵向单元格的合并，colspan用来设置横向单元格的合并 2.表格样式 分别给table和td设置border属性会有一个边框缝隙的效果(table和td之间有缝隙)，可以在table中border-spacing属性设置为0px来解决,但是边框重叠会有一个加粗的视觉效果 border-collapse：collapse(为表格设置合并边框的模式)，设置后border-spacing自动失效 隔行不同效果：tr:nth-child(odd/even) 3.长表格 分为三个部分：thead表头，tbody表格主题，tfoot表格底部 区分表格中不同的部分，都是table的子标签，直接写在table中，tr写在这几个子标签中 tfoot中的内容永远显示在表格底部，thead中的内容永远显示在表格头部 若表格没有写tbody，浏览器会自动生成tbody，并且把所有的tr都放入tbody中。注意：tr不是table的子元素，而是tbody的子元素 通过table &gt; tr无法选中tr，需要tbody &gt; tr 4.clearfix 可以解决高度塌陷，父元素和子元素的垂直外边距不会重叠的双重问题 12345.clearfix:after, .clearfix:before&#123; content: \"\"; display: table; clear: both;&#125; 十三.表单 网页中的表单用来向服务器提交信息，如：搜索框，登录，注册等 action属性：指向一个服务器的地址，表单内容会提交到相应的服务器地址 input标签 type属性为text，创建文本框，value属性指定了文本框的默认显示 type属性为submit，创建提交按钮，value属性指定按钮文字 type属性为reset，创建重置按钮，点击后表单内容恢复默认值 type属性为button，创建单纯的按钮，可用JS绑定事件 希望表单中的数据提交到服务器中，需要在文本框的input中添加name属性，表示提交内容的名字 用户填写的信息会附在url地址后边以查询字符串的形式发送给服务器：url地址?查询字符串(属性名=属性值 &amp; 属性名=属性值) type属性为password，文本框的输入不会明文显示 type属性为radio，单选按钮，通过name属性分组，name值相同为一组，对于这种不需要填写内容的表单项，必须设置value属性来提交给服务器 type属性为checkbox，多选按钮，通过name属性分组，name值相同为一组，对于这种不需要填写内容的表单项，必须设置value属性来提交给服务器 checked属性：设置单选和多选打开后的默认选项，值也为checked placeholder属性：在文本框和文本域中指定水印文字，IE8及以下不支持，需要使用JS select标签：创建下拉列表 option标签：创建列表项 下拉列表的name属性要指定给select，value属性要指定给option option的selected属性：设置下拉列表的默认选项，值也为selected multiple属性：multiple，多选下拉列表 optgroup标签：表单项分组，可以把option项写进optgroup，用label属性分组 textarea标签：多行文本域 button标签：创建按钮，和input的submit效果相同，也可以设置type来指定按钮类型。和input的区别在于button成对出现，而input只有一个标签 label标签：可以通过提示文字选中表单内容，但是需要绑定label中的for属性和input中的id属性，使得两者相同。 fieldset标签：可以划分表单域 legend标签：一般用于fieldset标签中，给每个表单域设置标题 十四.CSS-Hack1.条件hack 条件hack用于让某段语句在指定浏览器中显示，是一段特殊代码，只适用于IE10以下的浏览器 语法： 123&lt;!-- [if 关键词(可选) IE version(可选)]&gt;HTML代码块&lt;![endif]--&gt; 关键词 gt(greater than)：大于 gte(greater than or euqal)：大等于 lt(less than)：小于 lte(less than or equal)：小等于 !：非指定版本 2.属性hack 添加了_的样式只有IE6以下的浏览器认识 _background-color 添加了的样式只有IE7以下的浏览器认识 background-color 样式最后添加\\0，只有IE8以上的浏览器认识 background-color: red\\0 3.选择器hack 在选择器前添加 * html ，则该选择器只有IE6可以识别 hack不到万不得已尽量不使用","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://linxd1999.github.io/tags/CSS/"}]},{"title":"盒模型","slug":"盒子模型","date":"2019-11-21T14:56:42.078Z","updated":"2019-11-21T14:56:42.078Z","comments":true,"path":"2019/11/21/盒子模型/","link":"","permalink":"https://linxd1999.github.io/2019/11/21/盒子模型/","excerpt":"","text":"一.盒 CSS处理网页时，认为每个元素都包含在一个不可见的盒子里 我们只要把相应的盒子摆放到网页中相应的位置即可完成对网页的布局 组成： 内容区(content) 内边距(padding) 边框(border) 外边距(margin) 二.边框 width：内容区宽度 height：内容区高度 border-width：边框的宽度 可以分别指定四个边框的宽度(顺时针赋值) 如果指定四个值，则分别设置给上，右，下，左 如果指定三个值，则分别设置给上，左右，下 如果指定两个值，则分别设置给上下，左右 如果指定一个值，则设置给四条边 CSS还提供border-xxx-width，xxx可为top，right，bottom，left border-color：边框的颜色，赋值规则同上 border-xxx-color：xxx可为top，right，bottom，left border-style：边框的样式，赋值规则同上 none：没有边框 solid：实线边框 dotted：点状边框 dashed：虚线边框 double：双线边框 border：边框的简写样式，可同时设置四个边框的样式，且没有任何顺序要求，但是border只能一次性指定四条边，不能分别指定。 border-xxx：可以一次指定一条边的所有属性 三.内边距 内边距指的是盒子的内容区和盒子边框之间的距离，一共有四个方向的内边距 内边距会影响盒子的可见框的大小 盒子可见框的宽度=(border-left-width)+(padding-left)+width+(padding-right)+(border-right-width) padding-top：上内边距的宽度 padding-right：右内边距的宽度 padding-bottom：下内边距的宽度 padding-left：左内边距的宽度 padding可同时设置四个内边距的样式，原理同上 box-sizing属性：border-box(设置的边框和内边距是包含在width内的，内容区的实际宽度=width-(border+padding)的值) 四.外边距 外边距指的是当前盒子与其他盒子之间的距离，不会影响可见框的大小，但会影响盒子的位置 盒子有四个方向的外边距 margin-top：上外边距的宽度 margin-right：右外边距的宽度 margin-bottom：下外边距的宽度 margin-left：左外边距的宽度 margin可同时设置四个方向外边距的样式 由于页面中的元素都是靠左上摆放的，所以当设置上，左外边距时，会导致盒子自身的位置发生改变，设置右，下外边距会改变其他盒子的位置 外边距可以是负值，元素向反方向移动 margin还可以设置auto，一般只设置给水平方向的margin，如果只指定左外边距或右外边距的值为auto则会将外边距设置为最大值；垂直方向如果设置为auto，则默认为0 1234/*盒子居中，两侧外边距设置为相同的值 可以使元素自动在父元素中居中*/margin-left: auto;margin-right: auto; 垂直外边距的重叠：在垂直方向的相邻外边距会发生重叠，兄弟元素之间的相邻外边距会取最大值而不是取和。如果父子元素的垂直外边距相邻了，则子元素的外边距会设置给父元素 浏览器为了在页面中没有样式时，也可以有一个比较好的显示效果，所以为很多元素都设置了默认的margin和padding，而默认样式在正常情况下是不需要的，所以我们需要在设置样式之前把默认样式都去掉 五.内联元素的盒模型 内联元素不能设置width和height 内联元素可以设置水平方向的内边距，边框 内联元素可以设置垂直方向的内边距，边框，但不会影响页面的布局 水平方向的相邻外边距不会重叠，但会求和，内联元素不支持垂直外边距 内联元素和块元素可以相互转换 display样式可修改元素的类型 inline：内联元素 block：块元素 inline-block：行内块元素(使一个元素既有行内元素的特点又有块元素的特点，可设置宽高而不独占一行) none：此元素不显示，且不再占据页面的位置 visibility可修改元素的显示状态 visible：默认值，元素默认在页面显示 hidden：元素会隐藏不显示，但位置会继续保持 overflow属性：设置父元素如何处理子元素溢出的问题 visible：默认值，不对溢出内容做处理，元素会在父元素以外的位置显示 hidden：溢出的内容被修剪，不显示 scroll：会为父元素添加滚动条，通过滚动来查看完整的内容(不论是否溢出，都有水平和垂直的滚动条) auto：会根据需求自动添加滚动条 六.浮动 块元素在文档流中默认垂直排列，如果希望块元素可以脱离文档流，可以用float使块元素浮动从而脱离文档流 float：浮动元素，脱离文档流 none：默认值，元素默认在文档流中排列 left：元素会立即脱离文档流，向页面的左侧浮动 right：元素会立即脱离文档流，向页面的右侧浮动 元素浮动之后，它下边的元素会立即向上移动 元素浮动以后，它会尽量向页面的左上或是右上浮动，直到遇到父元素的边框或者其他的浮动元素 如果浮动元素上边是一个没有浮动的块元素，则浮动元素不会超过块元素 浮动元素不会超过它的兄弟元素，最多一边齐 块元素脱离文档流后，高度和宽度都会被内容撑开 内联元素脱离文档流后会变成块元素 文档流中，父元素的高度默认被子元素撑开。但子元素浮动后，会导致父元素高度塌陷，父元素下的所有元素都向上移动，页面布局混乱 可以将父元素的高度固定，父元素的高度将不能自适应子元素的高度，不推荐使用 设置overflow：(非visible的值) 在高度塌陷的父元素最后添加一个空白的div，由于此div没有浮动，所以可以撑开父元素，然后对它清除左右浮动即可(基本无副作用) 基于上一条，可以通过after伪类，选中父元素的最后边，转化为块元素，再清除浮动 12345.box1:after&#123; content: \"\"; display: block; clear: both;&#125; clear：清除浮动 none：默认值，不清除浮动 left：清除左侧浮动元素对当前元素的影响 right：清除右侧浮动元素对当前元素的影响 both：清除左右浮动元素中对当前元素影响最大的 七.定位 定位是将指定的元素摆放到页面的任意位置，通过定位可以任意的摆放元素 position属性：设置元素的定位 static：默认值，元素没有开启定位 relative：开启元素的相对定位 absolute：开启元素的绝对定位 fixed：开启元素的固定定位(绝对定位的一种) 1.相对定位 position设置成relative时，则开启了元素的相对定位，元素不会脱离文档流，但会使元素提高一个层级，不会改变元素的性质，块还是块，内联还是内联 开启相对定位但不设置偏移量时，元素不会发生任何变化 可以通过left，right，top，bottom四个属性来设置元素的偏移量 left：元素相对于原定位位置的左侧偏移量 right：元素相对于原定位位置的右侧偏移量 top：元素相对于原定位位置的上侧偏移量 bottom：元素相对于原定位位置的下侧偏移量 通常偏移量只需要使用两个就可以对一个元素进行定位，一般选择水平方向的一个偏移量和垂直方向的偏移量来为一个元素进行定位 2.绝对定位 positon设置成absolute时，开启元素的绝对定位，元素会脱离文档流 开启绝对定位但不设置偏移量时，元素位置不变 绝对定位是相对于离他最近的开启了定位的祖先元素进行定位，如果所有的祖先元素都没有开启定位，则相对于浏览器窗口进行定位(一般情况下，开启了子元素的绝对定位都会同时开启父元素的相对定位) 绝对定位会使元素提升一个层级 绝对定位会改变元素的性质，内联元素变成块元素 3.固定定位 position设置为fixed时，开启元素的固定定位 固定定位也是一种绝对定位，大部分特点和绝对定位一样，但有一些不同 固定定位永远相对于浏览器窗口进行定位 固定定位会固定在浏览器窗口的某个位置，不会随滚动条滚动(牛皮癣广告) IE6不支持固定定位 4.元素层级 如果定位元素的层级一样，则下边的元素会盖住上边的 通过z-index属性可设置元素的层级(数字越大，层级越大，越优先显示) 对于没有开启定位的元素不能使用z-index属性 5.透明背景 opacity属性：设置背景的透明度，值为0-1 0表示完全透明 0.5表示半透明 1表示完全不透明 opacity在IE8以下的浏览器不支持，需要用alpha(opacity=透明度)代替 需要一个0-100之间的值 0表示完全透明 100表示完全不透明 50表示半透明","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://linxd1999.github.io/tags/CSS/"}]},{"title":"模拟函数栈实现非递归遍历二叉树","slug":"树的遍历","date":"2019-09-28T07:57:53.543Z","updated":"2019-09-28T07:57:53.543Z","comments":true,"path":"2019/09/28/树的遍历/","link":"","permalink":"https://linxd1999.github.io/2019/09/28/树的遍历/","excerpt":"","text":"一.思想 递归实现的遍历是基于函数栈的不断返回完成的，所以我们也可以用栈这个数据结构来模拟这种函数栈的返回 这种方法可以实现前序，中序，后序遍历写出基本一致的代码，只不过入栈顺序不同 使用颜色标记节点状态，新节点为白色，访问过的节点为灰色。白色意味着继续递归，灰色意味着在函数栈返回时可将该节点存入结果集中 栈顶节点为白色，则将其标记为灰色，然后将其自身，左子节点，右子结点按指定顺序依次入栈 栈顶节点为灰色，则将节点的值输出 例如前序遍历：前序遍历的顺序是根左右，所以入栈顺序就应该是右左根(基于栈的先进后出原则) 参考：力扣题解 代码：代码仓库 二.实现代码 前序遍历 123456789101112131415161718192021222324252627282930class Solution &#123; public enum color&#123; White,Grey; &#125; class isRecursion&#123; color c; TreeNode n; public isRecursion(color c,TreeNode n) &#123; this.c = c; this.n = n; &#125; &#125; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); Stack&lt;isRecursion&gt; s = new Stack&lt;&gt;(); s.push(new isRecursion(color.White,root)); while(!s.isEmpty()) &#123; isRecursion temp = s.pop(); if(temp.n == null) continue; if(temp.c == color.White) &#123; if(temp.n.right != null) s.push(new isRecursion(color.White,temp.n.right)); if(temp.n.left != null) s.push(new isRecursion(color.White,temp.n.left)); s.push(new isRecursion(color.Grey,temp.n)); &#125;else &#123; res.add(temp.n.val); &#125; &#125; return res; &#125;&#125; 中序遍历 123456789101112131415161718192021222324252627282930class Solution &#123; public enum color&#123; White,Grey; &#125; class isRecursion&#123; color c; TreeNode n; public isRecursion(color c,TreeNode n) &#123; this.c = c; this.n = n; &#125; &#125; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); Stack&lt;isRecursion&gt; s = new Stack&lt;&gt;(); s.push(new isRecursion(color.White,root)); while(!s.isEmpty()) &#123; isRecursion temp = s.pop(); if(temp.n == null) continue; if(temp.c == color.White) &#123; if(temp.n.right != null) s.push(new isRecursion(color.White,temp.n.right)); s.push(new isRecursion(color.Grey,temp.n)); if(temp.n.left != null) s.push(new isRecursion(color.White,temp.n.left)); &#125;else &#123; res.add(temp.n.val); &#125; &#125; return res; &#125;&#125; 后序遍历 123456789101112131415161718192021222324252627282930class Solution &#123; public enum color&#123; White,Grey; &#125; class isRecursion&#123; color c; TreeNode n; public isRecursion(color c,TreeNode n) &#123; this.c = c; this.n = n; &#125; &#125; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); Stack&lt;isRecursion&gt; s = new Stack&lt;&gt;(); s.push(new isRecursion(color.White,root)); while(!s.isEmpty()) &#123; isRecursion temp = s.pop(); if(temp.n == null) continue; if(temp.c == color.White) &#123; s.push(new isRecursion(color.Grey,temp.n)); if(temp.n.right != null) s.push(new isRecursion(color.White,temp.n.right)); if(temp.n.left != null) s.push(new isRecursion(color.White,temp.n.left)); &#125;else &#123; res.add(temp.n.val); &#125; &#125; return res; &#125;&#125;","categories":[],"tags":[{"name":"Tree","slug":"Tree","permalink":"https://linxd1999.github.io/tags/Tree/"}]},{"title":"","slug":"HTML","date":"2019-09-21T12:59:48.262Z","updated":"2019-09-21T12:59:48.262Z","comments":true,"path":"2019/09/21/HTML/","link":"","permalink":"https://linxd1999.github.io/2019/09/21/HTML/","excerpt":"","text":"HTML链接 a标签： 文本链接、图片链接 属性： href：指向另一个文档的链接 name：创建文档内的链接（锚点链接：指向同一个页面内另一处文本段落的链接） img标签属性： alt：替换文本属性 width：宽(px) height：高(px) HTML表格 table标签： 属性： 边框：border 内间距：cellpadding 侧边距：cellspacing 背景颜色：bgcolor 背景图片：background ：单元格 ：表格行 HTML列表 无序列表：使用标签、 属性：(type)disc、circle、square 有序列表：使用标签、 属性：(type)A、a、I、i 嵌套列表：使用标签、、 自定义列表：、、 HTML块 块元素：显示时以新行开始 如、、 内联元素：通常不从新行开始 如、、 div元素：组合html元素的容器，为大块内容提供结构和背景，其中所含元素的特性由div标签的属性来控制 span元素：内联元素，可做文本容器，一般用于改部分文本的样式 div,section,article元素 这三个都是针对一块区域做布局的标签 语义逐渐增强，可嵌套 div本身无语义，用作布局及css样式化 section用作一段有专题性的内容， 里面基本上会带有标题 article用作一段独立的，完整的内容块 nav元素 页面导航的链接组 传统导航条，侧边栏导航，页内导航，翻页操作","categories":[],"tags":[]},{"title":"排序算法","slug":"排序","date":"2019-09-19T02:11:38.838Z","updated":"2019-09-19T02:11:38.838Z","comments":true,"path":"2019/09/19/排序/","link":"","permalink":"https://linxd1999.github.io/2019/09/19/排序/","excerpt":"","text":"一.冒泡排序 冒泡排序实质上就是让相邻两个数比较，较大数向右走，每轮可以确定一个最大的数 123456789101112131415161718192021222324252627public class BubbleSort &#123; public static void main(String[] args) &#123; int arr[] = &#123;3,9,-1,10,-2&#125;; bubbleSort(arr); System.out.println(Arrays.toString(arr)); &#125; public static void bubbleSort(int []arr) &#123; int temp = 0; boolean f = false; //冒泡排序的时间复杂度:O(n^2) for(int i = 0; i &lt; arr.length-1; i++) &#123; for(int j = 0; j &lt; arr.length-1-i; j++) &#123; if(arr[j]&gt;arr[j+1]) &#123; f = true; temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; if(f == false) &#123; break; &#125;else &#123; f = false; &#125; &#125; &#125;&#125; 二.选择排序 选择排序的实质就是每轮选出一个最小的数放到数组的最前面 1234567891011121314151617181920212223public class SelectSort &#123; public static void main(String[] args) &#123; int arr[] = &#123;3,9,-1,10,-2&#125;; selectSort(arr); System.out.println(Arrays.toString(arr)); &#125; public static void selectSort(int []arr) &#123; for(int i = 0; i &lt; arr.length-1; i++) &#123; int min = arr[i]; int minIndex = i; for(int j = i+1;j&lt;arr.length; j++) &#123; if(min &gt; arr[j]) &#123; min = arr[j]; minIndex = j; &#125; &#125; if(minIndex != i) &#123; arr[minIndex] = arr[i]; arr[i] = min; &#125; &#125; &#125;&#125; 三.插入排序 插入排序就是把数组分成一个无序表和一个有序表，第一个有序表是第一个元素，然后每轮把后一个元素插入合适的位置使整个数组都变为有序表 123456789101112131415161718192021222324public class InsertSort &#123; public static void main(String[] args) &#123; int arr[] = &#123;3,9,-1,10,-2&#125;; insertSort(arr); System.out.println(Arrays.toString(arr)); &#125; public static void insertSort(int [] arr) &#123; int insertVal = 0; int insertIndex = 0; for(int i = 1; i &lt; arr.length; i++) &#123; insertVal = arr[i]; insertIndex = i-1;// 给insertVal找插入的位置 while(insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) &#123; arr[insertIndex+1] = arr[insertIndex]; insertIndex--; &#125; //当退出循环时，插入位置找到,insertIndex+1 if(insertIndex+1 != i) &#123; arr[insertIndex+1] = insertVal; &#125; &#125; &#125;&#125; 四.希尔排序 插入排序中，小的数如果在很后面的话，每次都要移动很长的距离 所以为了解决这个问题，希尔排序使用了一种增量，每次排序都在宏观上把小数往前移，可以使较小的数都出现在数组前部，然后每轮缩小增量直至增量为1。 分为交换式和移位式，移位式效率更高。 12345678910111213141516171819202122232425262728293031323334353637383940414243public class ShellSort &#123; public static void main(String[] args) &#123; int arr[] = &#123; 8, 9, 1, 7, 2, 3, 5, 4, 6, 0 &#125;; //shellSort1(arr); //shellSort2(arr); &#125; // 交换式 public static void shellSort1(int[] arr) &#123; int temp = 0; for (int gap = arr.length / 2; gap &gt; 0; gap /= 2) &#123; for (int i = gap; i &lt; arr.length; i++) &#123; for (int j = i - gap; j &gt;= 0; j -= gap) &#123; if (arr[j] &gt; arr[j + gap]) &#123; temp = arr[j]; arr[j] = arr[gap + j]; arr[gap + j] = temp; &#125; &#125; &#125; System.out.println(Arrays.toString(arr)); &#125; &#125; // 移位式 public static void shellSort2(int[] arr) &#123; int temp = 0; for (int gap = arr.length / 2; gap &gt; 0; gap /= 2) &#123; for (int i = gap; i &lt; arr.length; i++) &#123; int j = i; temp = arr[i]; if (arr[j] &lt; arr[j - gap]) &#123; while (j - gap &gt;= 0 &amp;&amp; temp &lt; arr[j - gap]) &#123; arr[j] = arr[j - gap]; j -= gap; &#125; arr[j] = temp; &#125; &#125; System.out.println(Arrays.toString(arr)); &#125; &#125;&#125;","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://linxd1999.github.io/tags/Algorithm/"}]},{"title":"","slug":"Collection集合","date":"2019-09-04T14:01:18.674Z","updated":"2019-09-04T14:01:18.674Z","comments":true,"path":"2019/09/04/Collection集合/","link":"","permalink":"https://linxd1999.github.io/2019/09/04/Collection集合/","excerpt":"","text":"Collection集合 集合中只能保存对象的引用变量 List子接口：有序，可重复集合(ArrayList、LinkedList、Vector) Set子接口：无序，不可重复集合(HashSet、LinkedHashSet、TreeSet) Queue子接口：先进先出队列 Lambda表达式遍历集合 Connection接口继承了Iterable接口 Java8新增了一个forEach(Consumer action)方法，参数是消费者(函数式接口) 程序将元素依次传给Consumer的accept()，该方法是接口中唯一的抽象方法 12345List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(\"hello\");list.add(\"world\");list.add(\"java\");list.forEach(obj-&gt;System.out.println(obj)); 类似，Iterator的forEachRemaining(Consumer action)同样可以使用lambda表达式遍历迭代器 1it.forEachRemaining(obj-&gt;System.out.println(obj)); List集合 特点：有序、可重复 新增方法： 12345678910111213List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(\"hello\");list.add(\"world\");list.add(\"java\");//在指定位置添加指定元素list.add(1, \"a\");//删除指定位置元素，返回被删除的元素System.out.println(list.remove(2));//修改指定位置的元素，返回被修改的元素System.out.println(list.set(2, \"javase\"));//返回指定索引处的元素System.out.println(list.get(2));System.out.println(list); 并发修改异常(ConcurrentModificationException) 产生原因：迭代器遍历过程中，通过集合对象修改了集合中元素的长度导致的迭代器获取元素中预期修改值和实际修改值不一致 解决：用for循环替代迭代遍历，用get()获取元素 ListIterator List特有的迭代器 可从任一方向遍历集合 新增add()方法，且底层经过优化，在迭代遍历中用迭代器增加集合内的元素不会抛出并发修改异常。 1234while(it.hasPrevious()) &#123; String s = (String)it.previous(); System.out.println(s);&#125; 增强for循环实际上还是Iterator，迭代时也不能修改元素长度 LinkedList集合 特有方法： 123456public void addFirst(E e)public void addLast(E e)public E getFirst()public E getLast()public E removeFirst()public E removeLast() Set集合 特点：无序，不可重复 没有带索引的方法，不能用普通for循环遍历 哈希值：JDK根据对象的地址或者字符串或者数字算出来的int值 同一个对象多次调用hashCode()方法返回相同哈希值 默认情况下，不同对象的哈希值不同，可通过重写hashCode()方法，可以实现让不同对象的哈希值相同 HashSet集合 底层数据结构是HashMap，由数组和链表构成 存取顺序不做保证 保证元素唯一性：存入元素和以前元素比较哈希值 如果哈希值不同，继续执行，把元素添加入集合 如果哈希值相同，调用equals()方法比较 返回false，继续执行，把元素添加到集合 返回true，说明元素重复，不存储 要保证元素唯一性，需要重写hashCode()和equals() LinkedHashSet 哈希表和链表构成，元素有次序 元素不可重复 TreeSet 元素会按照一定的规则排序，取决于构造方法 TreeSet()：自然排序 TreeSet(Comparator comparator)：根据指定的比较器进行排序 自然排序Comparable 元素所属类实现Comparable接口，重写compareTo(T o)方法 重写方法必须注意按照要求的主要和次要条件来写 compareTo()方法有this，this在前面表示升序 123456789101112131415161718192021222324252627282930313233343536373839import java.util.TreeSet;public class TreeSetDemo &#123; public static void main(String[] args) &#123; TreeSet&lt;Student&gt; ts = new TreeSet&lt;&gt;(); Student s1 = new Student(\"a\",29); Student s2 = new Student(\"c\",28); Student s3 = new Student(\"d\",30); Student s4 = new Student(\"b\",33); Student s5 = new Student(\"c\",33); ts.add(s1); ts.add(s2); ts.add(s3); ts.add(s4); ts.add(s5); ts.forEach(obj-&gt;System.out.println(obj.getName()+\" \"+obj.getAge())); &#125;&#125;class Student implements Comparable&lt;Student&gt;&#123; private String name; private int age; public Student(String name,int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; @Override public int compareTo(Student o) &#123; int num = this.age-o.age; int num2 = num==0 ? this.name.compareTo(o.name) : num; return num2; &#125;&#125; 比较器排序Comparator 重写Comparator的compare(T o1,T o2)方法 123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.*;public class TreeSetDemo &#123; public static void main(String[] args) &#123; TreeSet&lt;Student&gt; ts = new TreeSet&lt;&gt;(new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; int num = o1.getAge()-o2.getAge(); int num2 = num==0 ? o1.getName().compareTo(o2.getName()) : num; return num2; &#125; &#125;); Student s1 = new Student(\"a\",29); Student s2 = new Student(\"c\",28); Student s3 = new Student(\"d\",30); Student s4 = new Student(\"b\",33); Student s5 = new Student(\"c\",33); ts.add(s1); ts.add(s2); ts.add(s3); ts.add(s4); ts.add(s5); ts.forEach(obj-&gt;System.out.println(obj.getName()+\" \"+obj.getAge())); &#125;&#125;class Student&#123; private String name; private int age; public Student(String name,int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125;&#125; Map集合 将键映射到值的对象，不能包含重复键，键可以映射最多一个值 添加元素时，如果键一样，值会被覆盖","categories":[],"tags":[]},{"title":"String、StringBuffer、StringBuilder类","slug":"String、StringBuffer、StringBuilder类","date":"2019-08-30T15:12:26.564Z","updated":"2019-08-30T15:12:26.564Z","comments":true,"path":"2019/08/30/String、StringBuffer、StringBuilder类/","link":"","permalink":"https://linxd1999.github.io/2019/08/30/String、StringBuffer、StringBuilder类/","excerpt":"","text":"一.字符串常量池字符串常量池属于Java的静态常量池，即.class文件中的常量池，占用class文件的大部分空间，还保存一些类、方法、接口中的常量。 String.intern()方法：查找常量池中是否存在该字符串，若存在则返回字符串的引用，若不存在则把该字符串添加进常量池并返回引用。 “abc”和new String(“abc”)的区别 在编译时候就能计算出的字符串值，JVM用常量池管理这些字符串 new一个字符串时，先用常量池管理该字符串，然后再用构造器创建一个新String对象，保存在堆内存中，共产生两个对象 常量池保证相同的字符串直接量只有一个，可以多个引用指向同一个常量。 常量池避免频繁创建销毁对象，实现对象共享，节省内存和运行时间。 12345678910String s1 = \"abc\";String s2 = \"ab\" + \"c\";String s3 = \"ab\";String s4 = \"c\";String s5 = s3 + s4;String s6 = new String(\"abc\");System.out.println(s1 == s2);//trueSystem.out.println(s1 == s5);//falseSystem.out.println(s1 == s5.intern());//trueSystem.out.println(s1 == s6);//false ==表示比较两个引用变量指向的地址。 s1 == s2：编译器会在编译期间自动把已知字符串拼接好，并放入常量池 s1 != s5：s5不能在编译期间确定，地址不能确定 s1 == s5.intern()：intern方法检测出s5内容存在于常量池中，返回字符串引用 s1 != s6：构造器生成的字符串编译时地址不能确定 二.StringBuffer和StringBuilderStringBuffer对象是一个字符序列可变的字符串 StringBuilder是JDK1.5之后新增的类，操作和StringBuffer基本一样 这两个类都解决了大量拼接字符串时产生很多中间对象而影响性能的问题 区别：StringBuffer线程安全，效率低；StringBuilder线程不安全，效率高，所以StringBuilder使用的多，尤其是单线程应用。 123456789101112131415StringBuilder sb = new StringBuilder();for(int i = 0; i &lt; 26; i++) &#123; sb.append((char)('a'+i));&#125;System.out.println(sb);//abcdefghijklmnopqrstuvwxyzSystem.out.println(sb.hashCode());//664740647sb.reverse();System.out.println(sb);//zyxwvutsrqponmlkjihgfedcbaSystem.out.println(sb.hashCode());//664740647sb.setCharAt(0, 'A');System.out.println(sb);//Ayxwvutsrqponmlkjihgfedcbasb.insert(1, \"bcd\");System.out.println(sb);//Abcdyxwvutsrqponmlkjihgfedcbasb.delete(0, 4);System.out.println(sb);//yxwvutsrqponmlkjihgfedcba 几个常用方法： append()：追加 reverse()：倒序 setCharAt()：修改某位置字符 setLength()：设置字符串长度 insert()：在某位置添加字符或字符串 delete()：删除某位置的字符","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://linxd1999.github.io/tags/Java/"}]},{"title":"面向对象(类、继承、多态)","slug":"面向对象(类、继承、多态)","date":"2019-08-24T16:46:55.613Z","updated":"2019-08-24T16:46:55.613Z","comments":true,"path":"2019/08/25/面向对象(类、继承、多态)/","link":"","permalink":"https://linxd1999.github.io/2019/08/25/面向对象(类、继承、多态)/","excerpt":"","text":"一. 类、对象、引用、指针1.引用变量及内存分析众所周知Java没有指针，但实际上Java的引用就相当于指针，只不过把这个指针封装起来，避免其繁琐的操作。 例如Person p = new Person()，这行代码创建了一个实例，实际上，p作为一个引用变量(只存放对象地址)存放在调用这行代码的方法栈中，而Person作为一个对象被存放在堆内存中，然后引用变量p指向堆里的Person。Java程序不允许直接访问堆内对象，只能通过引用变量来访问。若堆内的对象没有任何引用变量指向它，则这个对象会被GC回收，反之，若想让GC回收某对象，只需要切断所有引用变量跟这个对象的联系即可。 2.this关键字this关键字总是指向调用该方法的对象，其最大的作用就是让类里的一个方法调用类里的另外一个方法或者实例变量。 Java允许对象的一个成员直接调用另一个成员可以忽略this前缀。 3.static关键字static关键字的真正作用：区分成员变量，方法，内部类是属于类本身还是属于类的实例 有static修饰的成员属于类本身，没有static修饰的成员属于类的实例。 因为static成员属于类本身，所以调用static成员是什么实例并不明确，所以不能在static方法内使用this关键字、super关键字。 方法以this作为返回值：可以在一行代码中多次连续调用该方法。 4.参数传递机制1234567891011121314151617 public class Swap &#123; int a,b; public Swap(int a,int b) &#123; this.a = a; this.b = b; &#125; public static void swap(Swap temp) &#123; int tmp = temp.a; temp.a = temp.b; temp.b = tmp; &#125; public static void main(String args[]) &#123; Swap s = new Swap(3,4); swap(s); System.out.println(s.a+\" \"+s.b); &#125;&#125; 首先在main函数内，main函数的栈内存放了引用变量s，指向堆内存的对象Swap；swap函数传入一个形参temp也指向堆内存里的Swap对象。所以两个引用变量都指向堆内存中的对象，只要操作一个引用变量，堆内存中对象的数据就会改变，所以数据交换可以成功。 5.成员变量、局部变量成员变量：不被static修饰的实例变量，被static修饰的类变量 局部变量：形参，方法中的变量，代码块中的变量 6.访问控制符private：当前类访问权限 default：包访问权限，可被相同包下的其他类访问 protected：子类访问权限，可被不同包中的子类访问 public：公共访问权限，可被所有类访问","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://linxd1999.github.io/tags/Java/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2019-08-09T17:17:13.445Z","updated":"2019-08-09T17:17:13.445Z","comments":true,"path":"2019/08/10/正则表达式/","link":"","permalink":"https://linxd1999.github.io/2019/08/10/正则表达式/","excerpt":"","text":"一、定义和规则 定义：正则表达式是一个非常强大的字符串处理工具，能对字符串进行查找，提取，分割，替换等操作 常用的正则表达式支持字符 裸字符：除了特殊字符，都可以直接匹配 \\uhhhh：Unicode万国码 ()：标记子表达式的位置 []：枚举或范围 {}：字符的出现频率 *：前面子表达式可以出现0或多次，相当于{0,} +：前面子表达式可以出现1或多次，相当于{1,} ?：前面子表达式可以出现0或1次，相当于{0,1} . ：匹配所有除了换行以外的字符 |：或 d是digit，s是space，w是word \\d：匹配0-9的所有数字，\\D是其补集 \\s：匹配空白字符，包括空格，回车，制表，换页等，\\S是其补集 \\w：匹配所有单词字符，包含数字，英文字母，下划线，\\W是其补集 -：范围符 [^]：求否 二、使用需要使用Pattern类和Matcher类 import java.util.regex.Matcher;import java.util.regex.Pattern; Pattern对象是正则表达式编译后在内存中的表示形式，多个Matcher对象可以共享一个Pattern对象 Matcher是匹配器，需要调用Pattern的matcher()结果来执行匹配 常用方法如下： find()：是否包含与正则表达式匹配的子串 group()：返回上一次匹配的子串 start()：返回上一次匹配的子串起始位置 end()：返回上一次匹配的子串结束位置+1 matches()：整个目标字符串与正则表达式是否匹配 reset()：重置匹配器，并可以启用新的需要匹配的字符串 例1：分离字符串中的整数 1234Matcher m = Pattern.compile(\"\\\\d+\").matcher(\"&lt;10|100&gt;\");while(m.find()) &#123; System.out.println(m.group());&#125; 例2：判断邮箱正确性 1234567891011121314151617String [] mails = &#123; \"lxd1999@qq.com\", \"lxd1999@163.com\", \"lxd1999@gmail.cn\", \"as@qq.ws\"&#125;;String RegEx = \"\\\\w&#123;3,20&#125;@\\\\w+\\\\.(com|cn)\";Pattern p = Pattern.compile(RegEx);Matcher m = null;for(String temp : mails) &#123; if(m==null) &#123; m = p.matcher(temp); &#125;else &#123; m.reset(temp); &#125; System.out.println(temp+(m.matches()?\"是\":\"不是\")+\"一个有效的邮件地址\"); &#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://linxd1999.github.io/tags/Java/"}]},{"title":"JDBC编程","slug":"jdbc","date":"2019-07-16T07:52:13.869Z","updated":"2019-07-16T07:52:13.869Z","comments":true,"path":"2019/07/16/jdbc/","link":"","permalink":"https://linxd1999.github.io/2019/07/16/jdbc/","excerpt":"","text":"一、JDBC简介JDBC(Java Database Connectivity):JAVA数据库连接，是可以执行sql语句的一套API 程序可通过JDBC连接到关系数据库，用sql对数据进行增删改查 通过JDBC开发的数据库应用可跨平台 数据库驱动程序：JDBC与数据库之间的转换层，负责将JDBC调用映射成特定的数据库调用 二、JDBC编程1.常用类和接口DriverManager：用于管理JDBC驱动的服务类，用于获取Connection对象 Connection：数据库连接对象，每个Connection代表一个连接会话。它是一个接口，可通过Statement，Preparedstatement来实例化，获取其对象 Statement：用于执行sql的工具接口 PreparedStatement：预编译的Statement对象，是Statement子接口，可以预编译sql语句，允许sql语句含参，方便后来修改也可避免每次都编译sql语句，性能好。 Statement和PreparedStatement都有execute()，executeUpdate()，executeQuery()，返回查询的结果集，executeUpdate()可执行DML语句，返回受影响的行数，executeQuery()可以执行DDL语句，返回结果集对象，所以一般不用execute()方法，返回的是ResultSet结果集。 ResultSet：结果集对象，包含很多查询结果的方法，可以根据列名或列索引来获取结果，也有很多种方法来移动记录指针，最常用的是next()方法。 2.步骤(以MySQL为例)123Connection conn = null;PreparedStatement pstmt = null;ResultSet rs = null; (1).加载数据库驱动1Class.forName(\"com.mysql.cj.jdbc.Driver\"); (2).获取数据库连接1conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/test?useSSL=false&amp;serverTimezone=UTC\",\"root\", \"password\"); (3).通过Connection创建PreparedStatement对象1pstmt = conn.prepareStatement(sql); (4).执行sql语句12rs = pstmt.executeQuery();result = pstmt.executeUpdate; 三、模板这些语句都可以被封装成单独的函数进行使用，更加方便，不用每次再进行定义。 下面是DAO模式分层后，最底层与数据库交互的BaseDao类，方便再使用时拷贝， 连接数据库还需要一个.property文件，里面记录了驱动，数据库位置，用户和密码，每次使用只需要改这里就可以 1234driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/test?useSSL=false&amp;serverTimezone=UTCuser=rootpassword=123456 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133/** * 数据库连接与关闭工具类。 */public class BaseDao &#123; public static String DRIVER; // 数据库驱动 public static String URL ; // url public static String DBNAME; // 数据库用户名 public static String DBPASS; // 数据库密码 Connection conn = null;// 数据连接对象 static&#123;//静态代码块,在类加载的时候执行 init(); &#125; /** * 初始化连接参数,从配置文件里获得 */ public static void init()&#123; Properties params=new Properties(); String configFile = \"database.properties\";//配置文件路径 //加载配置文件到输入流中 InputStream is=BaseDao.class.getClassLoader().getResourceAsStream(configFile); try &#123; //从输入流中读取属性列表 params.load(is); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //根据指定的获取对应的值 DRIVER=params.getProperty(\"driver\"); URL=params.getProperty(\"url\"); DBNAME=params.getProperty(\"user\"); DBPASS=params.getProperty(\"password\"); &#125; /** * 得到数据库连接 * * @throws ClassNotFoundException * @throws SQLException * @return 数据库连接 */ public Connection getConnection() throws ClassNotFoundException, SQLException &#123; Connection conn = null; try &#123; Class.forName(DRIVER); // 注册驱动 conn = DriverManager.getConnection(URL, DBNAME, DBPASS); // 获得数据库连接 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return conn; // 返回连接 &#125; /** * 释放资源 * * @param conn * 数据库连接 * @param pstmt * PreparedStatement对象 * @param rs * 结果集 */ public void closeAll(Connection conn, PreparedStatement pstmt, ResultSet rs) &#123; /* 如果rs不空，关闭rs */ if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /* 如果pstmt不空，关闭pstmt */ if (pstmt != null) &#123; try &#123; pstmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /* 如果conn不空，关闭conn */ if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 执行SQL语句，可以进行增、删、改的操作，不能执行查询 * * @param sql * 预编译的 SQL 语句 * @param param * 预编译的 SQL 语句中的‘？’参数的字符串数组 * @return 影响的条数 */ public int executeSQL(String preparedSql, Object[] param) &#123; Connection conn = null; PreparedStatement pstmt = null; int num = 0; /* 处理SQL,执行SQL */ try &#123; conn = getConnection(); // 得到数据库连接 pstmt = conn.prepareStatement(preparedSql); // 得到PreparedStatement对象 if (param != null) &#123; for (int i = 0; i &lt; param.length; i++) &#123; pstmt.setObject(i + 1, param[i]); // 为预编译sql设置参数 &#125; &#125; num = pstmt.executeUpdate(); // 执行SQL语句 &#125; catch (ClassNotFoundException e) &#123; //e.printStackTrace(); // 处理ClassNotFoundException异常 &#125; catch (SQLException e) &#123; //e.printStackTrace(); // 处理SQLException异常 &#125; finally &#123; this.closeAll(conn, pstmt, null); &#125; return num; &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://linxd1999.github.io/tags/Java/"}]},{"title":"Common Words and Phrases","slug":"常用单词和词组整理","date":"2019-06-13T07:44:28.521Z","updated":"2019-06-13T07:44:28.521Z","comments":true,"path":"2019/06/13/常用单词和词组整理/","link":"","permalink":"https://linxd1999.github.io/2019/06/13/常用单词和词组整理/","excerpt":"一、常用单词 中 英 统治 govern reign 推动、促进 promote boost facilitate 蓬勃发展 boom mushroom surge flourish thrive 兴荣的 prosperous booming thriving flourishing 稳定的 stable steady 大量、许多 multiple numerous 交易 deal(n.) trade(v.) 发行 publish(书、报纸) issue(钱/股票) 政府(管理) government administration 超过 exceed surpass 领域 field domain territory 激增 balloon soar multiply 骤降 plunge 显著的 notable noticeable remarkable prominent conspicuous 危险 risk danger jeopardy 处理、解决 solve settle tackle 加速 accelerate hasten 获得、收获 gain reap 破坏 destory devastate disrupt 观众 audience spectator 刺激、鼓舞 stimulate(stimulus) spur motivate 商品 goods commodity merchandise 成功的 successful triumphant 重要的 critical significant essential vital crucial 灿烂的 brilliant splendid glorious marvellous fascinating 同时 meanwhile simultaneously 著名的 famous celebrated noted renowned 比赛 competition race(运动) event(运动) 因此 therefore hence 渴望 long crave yearn 目的 purpose aim sake 实施、执行 implement execute 撤退 withdraw retreat 悲惨的 tragic miserable bleak(惨淡的) 缺点 defect flaw weakness shortcoming disadvantage 消失 disappear vanish 保证 promise guarantee pledge 预示 indicate herald anticipate 公平 justice fairness 面对 face confront 忽视、忽略 neglect overlook ignore 预测 predict forecast 分配 allocate allot assign 诱惑 tempt lure 巨大的 huge enormous tremendous massive 足够的 enough adequate sufficient 相同的 same uniform identical 驱使，引发 trigger provoke propel 削减 cut down cripple 剥夺 deprive strip 授权 authorize empower 让步、妥协 compromise concession","text":"一、常用单词 中 英 统治 govern reign 推动、促进 promote boost facilitate 蓬勃发展 boom mushroom surge flourish thrive 兴荣的 prosperous booming thriving flourishing 稳定的 stable steady 大量、许多 multiple numerous 交易 deal(n.) trade(v.) 发行 publish(书、报纸) issue(钱/股票) 政府(管理) government administration 超过 exceed surpass 领域 field domain territory 激增 balloon soar multiply 骤降 plunge 显著的 notable noticeable remarkable prominent conspicuous 危险 risk danger jeopardy 处理、解决 solve settle tackle 加速 accelerate hasten 获得、收获 gain reap 破坏 destory devastate disrupt 观众 audience spectator 刺激、鼓舞 stimulate(stimulus) spur motivate 商品 goods commodity merchandise 成功的 successful triumphant 重要的 critical significant essential vital crucial 灿烂的 brilliant splendid glorious marvellous fascinating 同时 meanwhile simultaneously 著名的 famous celebrated noted renowned 比赛 competition race(运动) event(运动) 因此 therefore hence 渴望 long crave yearn 目的 purpose aim sake 实施、执行 implement execute 撤退 withdraw retreat 悲惨的 tragic miserable bleak(惨淡的) 缺点 defect flaw weakness shortcoming disadvantage 消失 disappear vanish 保证 promise guarantee pledge 预示 indicate herald anticipate 公平 justice fairness 面对 face confront 忽视、忽略 neglect overlook ignore 预测 predict forecast 分配 allocate allot assign 诱惑 tempt lure 巨大的 huge enormous tremendous massive 足够的 enough adequate sufficient 相同的 same uniform identical 驱使，引发 trigger provoke propel 削减 cut down cripple 剥夺 deprive strip 授权 authorize empower 让步、妥协 compromise concession 规模：scale 大规模的：large-scale / mass 城市化：urbanization 边界/界限：boundary 边境/国界：border 大都市：metropolis 禁止：inhibit 栖息、居住于：inhabit 展示、展览：exhibit 把…归咎于：attribute 贡献：contribute 阻碍：hinder 可行的：feasible 合理的：rational 不合理的：irrational 无理由的：groundless 学科类 数学 mathematics 科学 science 哲学 philosophy 物理 physics 心理学 psychology 化学 chemistry 生物 biology 生物化学 biochemisty 政治 politics 文学 literature 体育 gymnastics 地理 geography 农业类 农业 agriculture 机械 machinery 农作物 crop 小麦 wheat 豆类 beans 水稻 rice 可开垦的 arable 耕作 cultivation 肥料 fertilizer 产量 yield 生产力(率) productivity 有机的 organic 无机的 inorganic 经济类 通货膨胀 inflation 波动 fluctuate 大幅削减 slash 基金 fund/capital 环境类 温室的 greenhouse 排放 emission 易受伤的 vulnerable 化石燃料 fossil fuel 负担 burden 生活类 体温计 thermometer 旗舰店 flagship store 所有物，财产 property 机构 agency 生的 raw 仓库 repository journal 旅游 journey 态度类 有野心的 ambitious 不情愿的 reluctant 模糊的 ambiguous 开明的 liberal 中立的 neutral 失望的 disappointed 二、常用词组占地…面积：with a area of / cover a area of 平方米(千米)：square meter(kilometer) 表范围：range in 长度/宽度/大小 from … to … 海拔：1000 meters above the sealevel / at an altitude of 1000 meters 在…西边多远：100 kilometers west of … 来源于… ：originate from… 追溯到：trace back to / date back to 另一方面：on the other hand / on the flip side","categories":[],"tags":[{"name":"English","slug":"English","permalink":"https://linxd1999.github.io/tags/English/"}]},{"title":"内存分页和分段","slug":"内存管理","date":"2019-06-04T16:10:09.082Z","updated":"2019-06-04T16:10:09.082Z","comments":true,"path":"2019/06/05/内存管理/","link":"","permalink":"https://linxd1999.github.io/2019/06/05/内存管理/","excerpt":"","text":"","categories":[],"tags":[{"name":"OS","slug":"OS","permalink":"https://linxd1999.github.io/tags/OS/"}]},{"title":"Hexo博客框架+GitHub部署","slug":"Hexo博客框架+GitHub部署","date":"2019-05-28T11:27:58.616Z","updated":"2019-05-28T11:27:58.616Z","comments":true,"path":"2019/05/28/Hexo博客框架+GitHub部署/","link":"","permalink":"https://linxd1999.github.io/2019/05/28/Hexo博客框架+GitHub部署/","excerpt":"特别感谢up主CodeSheep的视频教程, 原视频请点击Step1： 安装Node.jsNode.js官网下载: https://nodejs.org/en/download/ Step2： 安装GitGit是一个开源的分布式版本控制系统，是为了帮助管理Linux内核开发而开发的版本控制软件。 Git官网下载: https://www.git-scm.com/download/ 安装完之后鼠标右击会出现Git Bash Here， 这就相当于Linux终端，我们等会对博客的操作也都是在这里完成。","text":"特别感谢up主CodeSheep的视频教程, 原视频请点击Step1： 安装Node.jsNode.js官网下载: https://nodejs.org/en/download/ Step2： 安装GitGit是一个开源的分布式版本控制系统，是为了帮助管理Linux内核开发而开发的版本控制软件。 Git官网下载: https://www.git-scm.com/download/ 安装完之后鼠标右击会出现Git Bash Here， 这就相当于Linux终端，我们等会对博客的操作也都是在这里完成。 一些常用的Linux命令行操作： cd ：进入目录 cd ..：返回上一级目录 cd../..：返回上两级目录 pwd：显示当前路径 ls -l：显示当前路径下文件的详细信息 Step3： 安装HexoHexo是一个快速，简洁，高效的博客框架。Hexo使用Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用华丽的主题生成静态网页。 随便在一个盘下新建文件夹，用来操作博客用，后面我都用Blog来表示这个文件夹。 进入Blog文件夹，右键Git Bash Here，首先测试node和npm的版本。 输入命令： 然后安装一个cnpm提高下载速度： npm install -g cnpm –registry=https://registry.npm.taobao.org 测试cnpm： 然后安装Hexo： cnpm install -g hexo-cli 验证是否安装成功 hexo -v 安装成功！ 然后在根目录下执行： hexo init 这是建立整个项目，若Blog文件夹下出现了很多文件则说明成功了。 Step4：运行测试 hexo clean 清理缓存文件 hexo g 生成文件 hexo s 运行本地服务器 hexo d 部署到远端服务器 先在根目录下运行hexo s 然后打开浏览器，输入localhost:4000，出现以下界面 至此，本地环境已经搭建好了。 Step5：部署到Github上登录Github，创建一个新的仓库new repository，仓库名称为你的Github ID.github.io（必须是这这样写） 然后在根目录下安装一个Git部署插件 cnpm install –save hexo-deployer-git 在根目录下的_config.yml文件下修改一些配置 repo把打开仓库看到的那个git结尾的复制进来就好。 最后部署到远端：hexo d 之后会出现一些验证，照着提示做就可以了。 推送到远端成功后，在浏览器输入你的Github ID.github.io就可以访问博客了。","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://linxd1999.github.io/tags/Hexo/"}]},{"title":"记录一些好用的网站","slug":"记录一些好用的网站","date":"2019-05-17T14:25:08.735Z","updated":"2019-05-17T14:25:08.735Z","comments":true,"path":"2019/05/17/记录一些好用的网站/","link":"","permalink":"https://linxd1999.github.io/2019/05/17/记录一些好用的网站/","excerpt":"","text":"1、高清电脑壁纸(wallhaven)：https://alpha.wallhaven.cc/ 2、在线作图(ProcessOn)：https://www.processon.com/ 3、GitHub(面向开源及私有软件项目的托管平台)：https://github.com/ 4、Java学习：http://how2j.cn/ 5、Linux命令行学习：http://linuxcommand.org/","categories":[],"tags":[{"name":"推荐","slug":"推荐","permalink":"https://linxd1999.github.io/tags/推荐/"}]}]}
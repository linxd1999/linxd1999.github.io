{"meta":{"title":"L","subtitle":null,"description":"站在巨人的肩上","author":"linxd","url":"https://linxd1999.github.io","root":"/"},"pages":[{"title":"标签","date":"2019-05-28T09:46:12.000Z","updated":"2019-05-28T11:27:07.487Z","comments":true,"path":"tags/index.html","permalink":"https://linxd1999.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"String、StringBuffer、StringBuilder类","slug":"String、StringBuffer、StringBuilder类","date":"2019-08-30T15:12:26.564Z","updated":"2019-08-30T15:12:26.564Z","comments":true,"path":"2019/08/30/String、StringBuffer、StringBuilder类/","link":"","permalink":"https://linxd1999.github.io/2019/08/30/String、StringBuffer、StringBuilder类/","excerpt":"","text":"一.字符串常量池字符串常量池属于Java的静态常量池，即.class文件中的常量池，占用class文件的大部分空间，还保存一些类、方法、接口中的常量。 String.intern()方法：查找常量池中是否存在该字符串，若存在则返回字符串的引用，若不存在则把该字符串添加进常量池并返回引用。 “abc”和new String(“abc”)的区别 在编译时候就能计算出的字符串值，JVM用常量池管理这些字符串 new一个字符串时，先用常量池管理该字符串，然后再用构造器创建一个新String对象，保存在堆内存中，共产生两个对象 常量池保证相同的字符串直接量只有一个，可以多个引用指向同一个常量。 常量池避免频繁创建销毁对象，实现对象共享，节省内存和运行时间。 12345678910String s1 = \"abc\";String s2 = \"ab\" + \"c\";String s3 = \"ab\";String s4 = \"c\";String s5 = s3 + s4;String s6 = new String(\"abc\");System.out.println(s1 == s2);//trueSystem.out.println(s1 == s5);//falseSystem.out.println(s1 == s5.intern());//trueSystem.out.println(s1 == s6);//false ==表示比较两个引用变量指向的地址。 s1 == s2：编译器会在编译期间自动把已知字符串拼接好，并放入常量池 s1 != s5：s5不能在编译期间确定，地址不能确定 s1 == s5.intern()：intern方法检测出s5内容存在于常量池中，返回字符串引用 s1 != s6：构造器生成的字符串编译时地址不能确定 二.StringBuffer和StringBuilderStringBuffer对象是一个字符序列可变的字符串 StringBuilder是JDK1.5之后新增的类，操作和StringBuffer基本一样 这两个类都解决了大量拼接字符串时产生很多中间对象而影响性能的问题 区别：StringBuffer线程安全，效率低；StringBuilder线程不安全，效率高，所以StringBuilder使用的多，尤其是单线程应用。 123456789101112131415StringBuilder sb = new StringBuilder();for(int i = 0; i &lt; 26; i++) &#123; sb.append((char)('a'+i));&#125;System.out.println(sb);//abcdefghijklmnopqrstuvwxyzSystem.out.println(sb.hashCode());//664740647sb.reverse();System.out.println(sb);//zyxwvutsrqponmlkjihgfedcbaSystem.out.println(sb.hashCode());//664740647sb.setCharAt(0, 'A');System.out.println(sb);//Ayxwvutsrqponmlkjihgfedcbasb.insert(1, \"bcd\");System.out.println(sb);//Abcdyxwvutsrqponmlkjihgfedcbasb.delete(0, 4);System.out.println(sb);//yxwvutsrqponmlkjihgfedcba 几个常用方法： append()：追加 reverse()：倒序 setCharAt()：修改某位置字符 setLength()：设置字符串长度 insert()：在某位置添加字符或字符串 delete()：删除某位置的字符","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://linxd1999.github.io/tags/Java/"}]},{"title":"面向对象(类、继承、多态)","slug":"面向对象(类、继承、多态)","date":"2019-08-24T16:46:55.613Z","updated":"2019-08-24T16:46:55.613Z","comments":true,"path":"2019/08/25/面向对象(类、继承、多态)/","link":"","permalink":"https://linxd1999.github.io/2019/08/25/面向对象(类、继承、多态)/","excerpt":"","text":"一. 类、对象、引用、指针1.引用变量及内存分析众所周知Java没有指针，但实际上Java的引用就相当于指针，只不过把这个指针封装起来，避免其繁琐的操作。 例如Person p = new Person()，这行代码创建了一个实例，实际上，p作为一个引用变量(只存放对象地址)存放在调用这行代码的方法栈中，而Person作为一个对象被存放在堆内存中，然后引用变量p指向堆里的Person。Java程序不允许直接访问堆内对象，只能通过引用变量来访问。若堆内的对象没有任何引用变量指向它，则这个对象会被GC回收，反之，若想让GC回收某对象，只需要切断所有引用变量跟这个对象的联系即可。 2.this关键字this关键字总是指向调用该方法的对象，其最大的作用就是让类里的一个方法调用类里的另外一个方法或者实例变量。 Java允许对象的一个成员直接调用另一个成员可以忽略this前缀。 3.static关键字static关键字的真正作用：区分成员变量，方法，内部类是属于类本身还是属于类的实例 有static修饰的成员属于类本身，没有static修饰的成员属于类的实例。 因为static成员属于类本身，所以调用static成员是什么实例并不明确，所以不能在static方法内使用this关键字、super关键字。 方法以this作为返回值：可以在一行代码中多次连续调用该方法。 4.参数传递机制1234567891011121314151617 public class Swap &#123; int a,b; public Swap(int a,int b) &#123; this.a = a; this.b = b; &#125; public static void swap(Swap temp) &#123; int tmp = temp.a; temp.a = temp.b; temp.b = tmp; &#125; public static void main(String args[]) &#123; Swap s = new Swap(3,4); swap(s); System.out.println(s.a+\" \"+s.b); &#125;&#125; 首先在main函数内，main函数的栈内存放了引用变量s，指向堆内存的对象Swap；swap函数传入一个形参temp也指向堆内存里的Swap对象。所以两个引用变量都指向堆内存中的对象，只要操作一个引用变量，堆内存中对象的数据就会改变，所以数据交换可以成功。 5.成员变量、局部变量成员变量：不被static修饰的实例变量，被static修饰的类变量 局部变量：形参，方法中的变量，代码块中的变量 6.访问控制符private：当前类访问权限 default：包访问权限，可被相同包下的其他类访问 protected：子类访问权限，可被不同包中的子类访问 public：公共访问权限，可被所有类访问","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://linxd1999.github.io/tags/Java/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2019-08-09T17:17:13.445Z","updated":"2019-08-09T17:17:13.445Z","comments":true,"path":"2019/08/10/正则表达式/","link":"","permalink":"https://linxd1999.github.io/2019/08/10/正则表达式/","excerpt":"","text":"一、定义和规则 定义：正则表达式是一个非常强大的字符串处理工具，能对字符串进行查找，提取，分割，替换等操作 常用的正则表达式支持字符 裸字符：除了特殊字符，都可以直接匹配 \\uhhhh：Unicode万国码 ()：标记子表达式的位置 []：枚举或范围 {}：字符的出现频率 *：前面子表达式可以出现0或多次，相当于{0,} +：前面子表达式可以出现1或多次，相当于{1,} ?：前面子表达式可以出现0或1次，相当于{0,1} . ：匹配所有除了换行以外的字符 |：或 d是digit，s是space，w是word \\d：匹配0-9的所有数字，\\D是其补集 \\s：匹配空白字符，包括空格，回车，制表，换页等，\\S是其补集 \\w：匹配所有单词字符，包含数字，英文字母，下划线，\\W是其补集 -：范围符 [^]：求否 二、使用需要使用Pattern类和Matcher类 import java.util.regex.Matcher;import java.util.regex.Pattern; Pattern对象是正则表达式编译后在内存中的表示形式，多个Matcher对象可以共享一个Pattern对象 Matcher是匹配器，需要调用Pattern的matcher()结果来执行匹配 常用方法如下： find()：是否包含与正则表达式匹配的子串 group()：返回上一次匹配的子串 start()：返回上一次匹配的子串起始位置 end()：返回上一次匹配的子串结束位置+1 matches()：整个目标字符串与正则表达式是否匹配 reset()：重置匹配器，并可以启用新的需要匹配的字符串 例1：分离字符串中的整数 1234Matcher m = Pattern.compile(\"\\\\d+\").matcher(\"&lt;10|100&gt;\");while(m.find()) &#123; System.out.println(m.group());&#125; 例2：判断邮箱正确性 1234567891011121314151617String [] mails = &#123; \"lxd1999@qq.com\", \"lxd1999@163.com\", \"lxd1999@gmail.cn\", \"as@qq.ws\"&#125;;String RegEx = \"\\\\w&#123;3,20&#125;@\\\\w+\\\\.(com|cn)\";Pattern p = Pattern.compile(RegEx);Matcher m = null;for(String temp : mails) &#123; if(m==null) &#123; m = p.matcher(temp); &#125;else &#123; m.reset(temp); &#125; System.out.println(temp+(m.matches()?\"是\":\"不是\")+\"一个有效的邮件地址\"); &#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://linxd1999.github.io/tags/Java/"}]},{"title":"JDBC编程","slug":"jdbc","date":"2019-07-16T07:52:13.869Z","updated":"2019-07-16T07:52:13.869Z","comments":true,"path":"2019/07/16/jdbc/","link":"","permalink":"https://linxd1999.github.io/2019/07/16/jdbc/","excerpt":"","text":"一、JDBC简介JDBC(Java Database Connectivity):JAVA数据库连接，是可以执行sql语句的一套API 程序可通过JDBC连接到关系数据库，用sql对数据进行增删改查 通过JDBC开发的数据库应用可跨平台 数据库驱动程序：JDBC与数据库之间的转换层，负责将JDBC调用映射成特定的数据库调用 二、JDBC编程1.常用类和接口DriverManager：用于管理JDBC驱动的服务类，用于获取Connection对象 Connection：数据库连接对象，每个Connection代表一个连接会话。它是一个接口，可通过Statement，Preparedstatement来实例化，获取其对象 Statement：用于执行sql的工具接口 PreparedStatement：预编译的Statement对象，是Statement子接口，可以预编译sql语句，允许sql语句含参，方便后来修改也可避免每次都编译sql语句，性能好。 Statement和PreparedStatement都有execute()，executeUpdate()，executeQuery()，返回查询的结果集，executeUpdate()可执行DML语句，返回受影响的行数，executeQuery()可以执行DDL语句，返回结果集对象，所以一般不用execute()方法，返回的是ResultSet结果集。 ResultSet：结果集对象，包含很多查询结果的方法，可以根据列名或列索引来获取结果，也有很多种方法来移动记录指针，最常用的是next()方法。 2.步骤(以MySQL为例)123Connection conn = null;PreparedStatement pstmt = null;ResultSet rs = null; (1).加载数据库驱动1Class.forName(\"com.mysql.cj.jdbc.Driver\"); (2).获取数据库连接1conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/test?useSSL=false&amp;serverTimezone=UTC\",\"root\", \"password\"); (3).通过Connection创建PreparedStatement对象1pstmt = conn.prepareStatement(sql); (4).执行sql语句12rs = pstmt.executeQuery();result = pstmt.executeUpdate; 三、模板这些语句都可以被封装成单独的函数进行使用，更加方便，不用每次再进行定义。 下面是DAO模式分层后，最底层与数据库交互的BaseDao类，方便再使用时拷贝， 连接数据库还需要一个.property文件，里面记录了驱动，数据库位置，用户和密码，每次使用只需要改这里就可以 1234driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/test?useSSL=false&amp;serverTimezone=UTCuser=rootpassword=123456 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133/** * 数据库连接与关闭工具类。 */public class BaseDao &#123; public static String DRIVER; // 数据库驱动 public static String URL ; // url public static String DBNAME; // 数据库用户名 public static String DBPASS; // 数据库密码 Connection conn = null;// 数据连接对象 static&#123;//静态代码块,在类加载的时候执行 init(); &#125; /** * 初始化连接参数,从配置文件里获得 */ public static void init()&#123; Properties params=new Properties(); String configFile = \"database.properties\";//配置文件路径 //加载配置文件到输入流中 InputStream is=BaseDao.class.getClassLoader().getResourceAsStream(configFile); try &#123; //从输入流中读取属性列表 params.load(is); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //根据指定的获取对应的值 DRIVER=params.getProperty(\"driver\"); URL=params.getProperty(\"url\"); DBNAME=params.getProperty(\"user\"); DBPASS=params.getProperty(\"password\"); &#125; /** * 得到数据库连接 * * @throws ClassNotFoundException * @throws SQLException * @return 数据库连接 */ public Connection getConnection() throws ClassNotFoundException, SQLException &#123; Connection conn = null; try &#123; Class.forName(DRIVER); // 注册驱动 conn = DriverManager.getConnection(URL, DBNAME, DBPASS); // 获得数据库连接 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return conn; // 返回连接 &#125; /** * 释放资源 * * @param conn * 数据库连接 * @param pstmt * PreparedStatement对象 * @param rs * 结果集 */ public void closeAll(Connection conn, PreparedStatement pstmt, ResultSet rs) &#123; /* 如果rs不空，关闭rs */ if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /* 如果pstmt不空，关闭pstmt */ if (pstmt != null) &#123; try &#123; pstmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /* 如果conn不空，关闭conn */ if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 执行SQL语句，可以进行增、删、改的操作，不能执行查询 * * @param sql * 预编译的 SQL 语句 * @param param * 预编译的 SQL 语句中的‘？’参数的字符串数组 * @return 影响的条数 */ public int executeSQL(String preparedSql, Object[] param) &#123; Connection conn = null; PreparedStatement pstmt = null; int num = 0; /* 处理SQL,执行SQL */ try &#123; conn = getConnection(); // 得到数据库连接 pstmt = conn.prepareStatement(preparedSql); // 得到PreparedStatement对象 if (param != null) &#123; for (int i = 0; i &lt; param.length; i++) &#123; pstmt.setObject(i + 1, param[i]); // 为预编译sql设置参数 &#125; &#125; num = pstmt.executeUpdate(); // 执行SQL语句 &#125; catch (ClassNotFoundException e) &#123; //e.printStackTrace(); // 处理ClassNotFoundException异常 &#125; catch (SQLException e) &#123; //e.printStackTrace(); // 处理SQLException异常 &#125; finally &#123; this.closeAll(conn, pstmt, null); &#125; return num; &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://linxd1999.github.io/tags/Java/"}]},{"title":"进程管理","slug":"Process Management(1)-dispatch","date":"2019-06-16T15:51:31.245Z","updated":"2019-06-16T15:51:31.245Z","comments":true,"path":"2019/06/16/Process Management(1)-dispatch/","link":"","permalink":"https://linxd1999.github.io/2019/06/16/Process Management(1)-dispatch/","excerpt":"一、进程和线程1、进程 进程(Process)：一个具有独立功能的程序关于一个数据集合上的一次动态执行过程 进程的组成：代码段、程序处理的数据、程序计数器(指示下一条将运行的指令)、系统资源 进程的特点： 1、动态性：进程是进程实体的一次执行过程 2、并发性：多个进程同时存在于内存中并能在一段时间内同时运行 3、独立性：在传统OS中，进程是一个能独立运行、分配资源、调度的基本调度 4、异步性：进程按各自独立、不可预知的速度向前推进 进程控制块(PCB)：每个进程用来保存与该进程有关的各种状态信息，是进程存在的唯一标识 进程的状态：创建、运行、等待(阻塞)、就绪、结束 1、进程只能自己阻塞自己，只有自己知道自己什么时候需要等待事件发生 2、阻塞态不能直接转换成运行态 3、挂起态：进程没有占有内存空间，处于挂起态的进程映像在磁盘上 上下文切换：OS内核将旧进程的关联状态保存在其PCB中，然后装入经调度之后准备执行的新进程的已保存的关联状态","text":"一、进程和线程1、进程 进程(Process)：一个具有独立功能的程序关于一个数据集合上的一次动态执行过程 进程的组成：代码段、程序处理的数据、程序计数器(指示下一条将运行的指令)、系统资源 进程的特点： 1、动态性：进程是进程实体的一次执行过程 2、并发性：多个进程同时存在于内存中并能在一段时间内同时运行 3、独立性：在传统OS中，进程是一个能独立运行、分配资源、调度的基本调度 4、异步性：进程按各自独立、不可预知的速度向前推进 进程控制块(PCB)：每个进程用来保存与该进程有关的各种状态信息，是进程存在的唯一标识 进程的状态：创建、运行、等待(阻塞)、就绪、结束 1、进程只能自己阻塞自己，只有自己知道自己什么时候需要等待事件发生 2、阻塞态不能直接转换成运行态 3、挂起态：进程没有占有内存空间，处于挂起态的进程映像在磁盘上 上下文切换：OS内核将旧进程的关联状态保存在其PCB中，然后装入经调度之后准备执行的新进程的已保存的关联状态 2、线程 线程(Thread)：OS中能进行调度的最小单位，包含在进程之中，是进程中的实际运作单位 线程的组成：线程id、程序计数器、各种寄存器、栈 线程的特点：和属于同一进程的其他线程共享代码段、数据段和其他OS资源 例如：浏览器这个进程可分为很多页面线程，不同页面可以做不同的事情 线程的优点： 1、响应度高：部分线程阻塞或操作时间冗长，该程序仍然能执行下去，增加对用户的响应程度 2、资源共享：允许一个进程在同一个地址空间有多个活动的线程 3、经济：进程创建所需的内存和资源分配昂贵，而线程则相对经济 4、适合多处理器结构：单线程进程只能运行在一个CPU上，在多CPU上使用多线程加强了OS的并发能力 进程、线程的区别： 1、调度性：在传统OS中，拥有资源和独立调度分配的基本单位都是进程；在引入线程的OS中，线程是调度分配的基本单位，而进程是资源分配的基本单位 2、并发性：在引入线程的OS中，进程之间可以并发执行，同一进程的线程之间也可以并发执行，从而使OS有更好的并发性 3、拥有资源：进程拥有自己的资源，线程一般不拥有资源，但可以访问其所在进程的资源 4、系统开销：创建、撤销进程涉及系统资源的分配与回收，需要比线程的创建和撤销大得多的系统开销，进程切换的开销也远大于线程 二、进程调度(dispatch)1、调度层次 长期调度/高级调度/作业调度：把进程从磁盘中首次调入内存，只有进程离开系统时，才需要长期调度程序的调度。必定发生，但频率比较低。 中期调度/中级调度/内存调度：在分时操作系统中，将进程从内存调入磁盘，从而减少内存中的进程数据。之后需要时再重新调入内存，并从中断处继续执行。可能发生，频率中等。 短期调度/低级调度/进程调度：从就绪态中选择进程分配CPU，必定发生，且频率很高。 2、调度准则 CPU使用率：需要让CPU尽可能忙 吞吐量：单位时间内完成的进程数量 周转时间：从进程提交到进程完成所用的时间 等待时间：进程在就绪队列中等待所花费的时间之和 响应时间：从提交请求到产生第一响应的时间 3、调度算法1、先来先服务算法(FCFS)例：银行排队、打印机 方式：非抢占 调度时机：一个进程结束 特点：利于长进程，不利于短进程；利于CPU繁忙的作业，不利于IO繁忙的作业；不适用于分时，实时系统 2、 短作业优先调度算法(SJF)思想：优先对短作业或短进程进行处理的算法，如果两个进程长度相同，可用FCFS处理(插队+动态改变) 方式：非抢占 / 抢占(最短剩余时间优先调度) 调度时机：程序结束时 / 阻塞I/O时 特点：利于短进程，不利于长进程(饥饿)；不能保证紧迫作业及试运行(程序员可能提供虚假时间)；平均等待时间，平均周转时间最少；吞吐量很大(单位时间内运行的进程数多) 3、高优先级调度算法思想：优先对高优先级的进程进行处理 方式：抢占 / 非抢占 调度时机：程序结束时 / I/O阻塞时 / 更高优先级进程进入队列时 特点：满足紧迫作业需求；适用于实时系统；优先级分为动态优先级和静态优先级 4、轮转法调度算法(RR)思想：分时间片使各进程轮流获取CPU(10ms-100ms) 方式：抢占 调度时机：时间片用完 / 程序结束 特点：时间片大小讲究，太大退化为FCFS，太小上下文切换次数很多，开销大；适用于分时系统 5、高响应比优先算法响应比Rp = (等待时间+服务时间) / 服务时间 思想：优先选择响应比高的作业(从外存放到内存的过程中，包含的一个或多个进程) 方式：无(主要用于作业调度) 调度时机：无 特点：FCFS与SJF的平衡；克服饥饿，既能兼顾长作业，又能让短作业先运行 6、多级反馈队列算法思想：FCFS(每个窗口都排队)+优先级(每个窗口都有优先级)+时间片轮转(时间片成倍增加，最后一个窗口循环轮转)，多级反馈队列不必事先知道各种进程所需的执行时间，还可以满足各种类型的进程需要。 方式：综合 调度时机：综合 特点：短作业优先带来的等待时间降低，周转时间降低；长作业能得到处理 三、同步与互斥1、相关概念 临界资源：一次仅允许一个进程使用的资源(打印机，网卡，键盘，共享变量) 临界区：每个进程中访问临界资源的那段代码 信号量(semaphore)：用来保证两个或多个临界区代码不被并发调用 互斥：两个或以上进程，不同时进入关于同一组共享变量的临界区，否则可能发生时间相关的错误 同步：在多道程序环境下，进程并发执行，进程因相互协作完成某个操作的次序关系 PV操作：控制信号量的一组原子操作，P是等待(减法，检测，阻塞)，V是释放(加法，检测，唤醒) 2、实现互斥的方法1、硬件实现法 中断屏蔽法：进程切换大多源于中断，若没有切换，也就不需要互斥，所以屏蔽中断即可实现互斥 原子硬件指令法：TestAndSet、Swap 2、软件实现法 单标志法 思想：一个进程的进入临界区权限只能被另外一个进程赋予，但两个进程必须交替进入临界区，如果某个进程不进入临界区，那么另外一个进程也无法进入临界区，造成资源浪费 双标志先检查法 思想：一个进程进入临界区之前先查看临界区资源是否被访问，若没有被访问，则把自身标志位设置为true，若被访问则等待 双标志后检查法 思想：防止先检查法的同时进入临界区问题，先上锁，后检查(会因为两个进程因为争夺临界区过于强势导致没有一个进程能获取临界区资源，导致饥饿) Peterson算法 思想：”孔融让梨”的思想，虽然表示自己也想获取临界区资源，但主动询问对方是否想访问，若对方想访问临界区资源且自己谦让了，对方进入临界区 3、信号量的使用伪代码： 若s.value&gt;0，则临界区资源可以被获取 若s.value&lt;=0，则临界区满，需要排队获取 实现互斥：s.value=1 实现同步：s.value=0 1、 生产者与消费者问题特征：容器内的物品数量&lt;=容量 分析：生产者关注剩余空间(emtpy)；消费者关注已占有空间(full)；互斥信号量mutex(用于影响容器大小的语句两端) 有几个容器就需要几个互斥信号量mutex 2、读者与写者问题特征：资源是否被占用；写者可写文件，但读者只能访问 例：有读写两组进程共享一个文件，多个读者可同时访问文件，多个写者不能同时访问文件，读者和写者不能同时访问文件 四、死锁1、相关概念 死锁：两个或两个以上的进程(或线程)在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都无法推进下去 活锁：两个线程，都很谦让，最后导致两个线程都无法获取资源 饥饿：某个进程因为其他进程轮流占用CPU导致它很久无法占用CPU的情况 死锁产生原因： 应用程序层面：信号量使用不当 OS内核程序层面：不可抢占软硬件资源(多进程对有限不可抢占资源的竞争，进程申请资源的推进顺序不合理 死锁产生的必要条件 互斥条件：必须有临界资源 占有并等待：一个进程必须占有一个资源，并等待另一资源，而该资源为其他进程所占有 非抢占：资源不能被抢占 循环等待：一组等待进程，每个进程所请求的资源都被另一个进程所占有 处理死锁的策略：预防死锁，避免死锁，检测与解除死锁 预防死锁：通过扼杀其产生的必要条件 互斥：几乎行不通 不可抢占：强行抢占某资源 占有并等待：一次性把资源申请完 循环等待：顺序资源分配法 死锁避免：银行家算法(规划合理的资源申请顺序，安全序列)","categories":[],"tags":[{"name":"OS","slug":"OS","permalink":"https://linxd1999.github.io/tags/OS/"}]},{"title":"Common Words and Phrases","slug":"常用单词和词组整理","date":"2019-06-13T07:44:28.521Z","updated":"2019-06-13T07:44:28.521Z","comments":true,"path":"2019/06/13/常用单词和词组整理/","link":"","permalink":"https://linxd1999.github.io/2019/06/13/常用单词和词组整理/","excerpt":"一、常用单词 中 英 统治 govern reign 推动、促进 promote boost facilitate 蓬勃发展 boom mushroom surge flourish thrive 兴荣的 prosperous booming thriving flourishing 稳定的 stable steady 大量、许多 multiple numerous 交易 deal(n.) trade(v.) 发行 publish(书、报纸) issue(钱/股票) 政府(管理) government administration 超过 exceed surpass 领域 field domain territory 激增 balloon soar multiply 骤降 plunge 显著的 notable noticeable remarkable prominent conspicuous 危险 risk danger jeopardy 处理、解决 solve settle tackle 加速 accelerate hasten 获得、收获 gain reap 破坏 destory devastate disrupt 观众 audience spectator 刺激、鼓舞 stimulate(stimulus) spur motivate 商品 goods commodity merchandise 成功的 successful triumphant 重要的 critical significant essential vital crucial 灿烂的 brilliant splendid glorious marvellous fascinating 同时 meanwhile simultaneously 著名的 famous celebrated noted renowned 比赛 competition race(运动) event(运动) 因此 therefore hence 渴望 long crave yearn 目的 purpose aim sake 实施、执行 implement execute 撤退 withdraw retreat 悲惨的 tragic miserable bleak(惨淡的) 缺点 defect flaw weakness shortcoming disadvantage 消失 disappear vanish 保证 promise guarantee pledge 预示 indicate herald anticipate 公平 justice fairness 面对 face confront 忽视、忽略 neglect overlook ignore 预测 predict forecast 分配 allocate allot assign 诱惑 tempt lure 巨大的 huge enormous tremendous massive 足够的 enough adequate sufficient 相同的 same uniform identical 驱使，引发 trigger provoke propel 削减 cut down cripple 剥夺 deprive strip 授权 authorize empower 让步、妥协 compromise concession","text":"一、常用单词 中 英 统治 govern reign 推动、促进 promote boost facilitate 蓬勃发展 boom mushroom surge flourish thrive 兴荣的 prosperous booming thriving flourishing 稳定的 stable steady 大量、许多 multiple numerous 交易 deal(n.) trade(v.) 发行 publish(书、报纸) issue(钱/股票) 政府(管理) government administration 超过 exceed surpass 领域 field domain territory 激增 balloon soar multiply 骤降 plunge 显著的 notable noticeable remarkable prominent conspicuous 危险 risk danger jeopardy 处理、解决 solve settle tackle 加速 accelerate hasten 获得、收获 gain reap 破坏 destory devastate disrupt 观众 audience spectator 刺激、鼓舞 stimulate(stimulus) spur motivate 商品 goods commodity merchandise 成功的 successful triumphant 重要的 critical significant essential vital crucial 灿烂的 brilliant splendid glorious marvellous fascinating 同时 meanwhile simultaneously 著名的 famous celebrated noted renowned 比赛 competition race(运动) event(运动) 因此 therefore hence 渴望 long crave yearn 目的 purpose aim sake 实施、执行 implement execute 撤退 withdraw retreat 悲惨的 tragic miserable bleak(惨淡的) 缺点 defect flaw weakness shortcoming disadvantage 消失 disappear vanish 保证 promise guarantee pledge 预示 indicate herald anticipate 公平 justice fairness 面对 face confront 忽视、忽略 neglect overlook ignore 预测 predict forecast 分配 allocate allot assign 诱惑 tempt lure 巨大的 huge enormous tremendous massive 足够的 enough adequate sufficient 相同的 same uniform identical 驱使，引发 trigger provoke propel 削减 cut down cripple 剥夺 deprive strip 授权 authorize empower 让步、妥协 compromise concession 规模：scale 大规模的：large-scale / mass 城市化：urbanization 边界/界限：boundary 边境/国界：border 大都市：metropolis 禁止：inhibit 栖息、居住于：inhabit 展示、展览：exhibit 把…归咎于：attribute 贡献：contribute 阻碍：hinder 可行的：feasible 合理的：rational 不合理的：irrational 无理由的：groundless 学科类 数学 mathematics 科学 science 哲学 philosophy 物理 physics 心理学 psychology 化学 chemistry 生物 biology 生物化学 biochemisty 政治 politics 文学 literature 体育 gymnastics 地理 geography 农业类 农业 agriculture 机械 machinery 农作物 crop 小麦 wheat 豆类 beans 水稻 rice 可开垦的 arable 耕作 cultivation 肥料 fertilizer 产量 yield 生产力(率) productivity 有机的 organic 无机的 inorganic 经济类 通货膨胀 inflation 波动 fluctuate 大幅削减 slash 基金 fund/capital 环境类 温室的 greenhouse 排放 emission 易受伤的 vulnerable 化石燃料 fossil fuel 负担 burden 生活类 体温计 thermometer 旗舰店 flagship store 所有物，财产 property 机构 agency 生的 raw 仓库 repository journal 旅游 journey 态度类 有野心的 ambitious 不情愿的 reluctant 模糊的 ambiguous 开明的 liberal 中立的 neutral 失望的 disappointed 二、常用词组占地…面积：with a area of / cover a area of 平方米(千米)：square meter(kilometer) 表范围：range in 长度/宽度/大小 from … to … 海拔：1000 meters above the sealevel / at an altitude of 1000 meters 在…西边多远：100 kilometers west of … 来源于… ：originate from… 追溯到：trace back to / date back to 另一方面：on the other hand / on the flip side","categories":[],"tags":[{"name":"English","slug":"English","permalink":"https://linxd1999.github.io/tags/English/"}]},{"title":"内存分页和分段","slug":"内存管理","date":"2019-06-04T16:10:09.082Z","updated":"2019-06-04T16:10:09.082Z","comments":true,"path":"2019/06/05/内存管理/","link":"","permalink":"https://linxd1999.github.io/2019/06/05/内存管理/","excerpt":"","text":"","categories":[],"tags":[{"name":"OS","slug":"OS","permalink":"https://linxd1999.github.io/tags/OS/"}]},{"title":"进程管理(三)：死锁","slug":"Process Management(3)-deadlock","date":"2019-05-28T14:01:36.005Z","updated":"2019-05-28T14:01:36.005Z","comments":true,"path":"2019/05/28/Process Management(3)-deadlock/","link":"","permalink":"https://linxd1999.github.io/2019/05/28/Process Management(3)-deadlock/","excerpt":"","text":"","categories":[],"tags":[{"name":"OS","slug":"OS","permalink":"https://linxd1999.github.io/tags/OS/"}]},{"title":"进程管理(二)：同步与互斥","slug":"Process Management(2)-mutex","date":"2019-05-28T14:00:55.179Z","updated":"2019-05-28T14:00:55.179Z","comments":true,"path":"2019/05/28/Process Management(2)-mutex/","link":"","permalink":"https://linxd1999.github.io/2019/05/28/Process Management(2)-mutex/","excerpt":"","text":"","categories":[],"tags":[{"name":"OS","slug":"OS","permalink":"https://linxd1999.github.io/tags/OS/"}]},{"title":"Hexo博客框架+GitHub部署","slug":"Hexo博客框架+GitHub部署","date":"2019-05-28T11:27:58.616Z","updated":"2019-05-28T11:27:58.616Z","comments":true,"path":"2019/05/28/Hexo博客框架+GitHub部署/","link":"","permalink":"https://linxd1999.github.io/2019/05/28/Hexo博客框架+GitHub部署/","excerpt":"特别感谢up主CodeSheep的视频教程, 原视频请点击Step1： 安装Node.jsNode.js官网下载: https://nodejs.org/en/download/ Step2： 安装GitGit是一个开源的分布式版本控制系统，是为了帮助管理Linux内核开发而开发的版本控制软件。 Git官网下载: https://www.git-scm.com/download/ 安装完之后鼠标右击会出现Git Bash Here， 这就相当于Linux终端，我们等会对博客的操作也都是在这里完成。","text":"特别感谢up主CodeSheep的视频教程, 原视频请点击Step1： 安装Node.jsNode.js官网下载: https://nodejs.org/en/download/ Step2： 安装GitGit是一个开源的分布式版本控制系统，是为了帮助管理Linux内核开发而开发的版本控制软件。 Git官网下载: https://www.git-scm.com/download/ 安装完之后鼠标右击会出现Git Bash Here， 这就相当于Linux终端，我们等会对博客的操作也都是在这里完成。 一些常用的Linux命令行操作： cd ：进入目录 cd ..：返回上一级目录 cd../..：返回上两级目录 pwd：显示当前路径 ls -l：显示当前路径下文件的详细信息 Step3： 安装HexoHexo是一个快速，简洁，高效的博客框架。Hexo使用Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用华丽的主题生成静态网页。 随便在一个盘下新建文件夹，用来操作博客用，后面我都用Blog来表示这个文件夹。 进入Blog文件夹，右键Git Bash Here，首先测试node和npm的版本。 输入命令： 然后安装一个cnpm提高下载速度： npm install -g cnpm –registry=https://registry.npm.taobao.org 测试cnpm： 然后安装Hexo： cnpm install -g hexo-cli 验证是否安装成功 hexo -v 安装成功！ 然后在根目录下执行： hexo init 这是建立整个项目，若Blog文件夹下出现了很多文件则说明成功了。 Step4：运行测试 hexo clean 清理缓存文件 hexo g 生成文件 hexo s 运行本地服务器 hexo d 部署到远端服务器 先在根目录下运行hexo s 然后打开浏览器，输入localhost:4000，出现以下界面 至此，本地环境已经搭建好了。 Step5：部署到Github上登录Github，创建一个新的仓库new repository，仓库名称为你的Github ID.github.io（必须是这这样写） 然后在根目录下安装一个Git部署插件 cnpm install –save hexo-deployer-git 在根目录下的_config.yml文件下修改一些配置 repo把打开仓库看到的那个git结尾的复制进来就好。 最后部署到远端：hexo d 之后会出现一些验证，照着提示做就可以了。 推送到远端成功后，在浏览器输入你的Github ID.github.io就可以访问博客了。","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://linxd1999.github.io/tags/Hexo/"}]},{"title":"记录一些好用的网站","slug":"记录一些好用的网站","date":"2019-05-17T14:25:08.735Z","updated":"2019-05-17T14:25:08.735Z","comments":true,"path":"2019/05/17/记录一些好用的网站/","link":"","permalink":"https://linxd1999.github.io/2019/05/17/记录一些好用的网站/","excerpt":"","text":"1、高清电脑壁纸(wallhaven)：https://alpha.wallhaven.cc/ 2、在线作图(ProcessOn)：https://www.processon.com/ 3、GitHub(面向开源及私有软件项目的托管平台)：https://github.com/ 4、Java学习：http://how2j.cn/ 5、Linux命令行学习：http://linuxcommand.org/","categories":[],"tags":[{"name":"推荐","slug":"推荐","permalink":"https://linxd1999.github.io/tags/推荐/"}]}]}
{"meta":{"title":"L","subtitle":null,"description":"站在巨人的肩上","author":"linxd","url":"https://linxd1999.github.io","root":"/"},"pages":[{"title":"标签","date":"2019-05-28T09:46:12.000Z","updated":"2019-05-28T11:27:07.487Z","comments":true,"path":"tags/index.html","permalink":"https://linxd1999.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"Git","date":"2019-11-16T04:25:31.683Z","updated":"2019-11-16T04:25:31.668Z","comments":true,"path":"2019/11/16/Git/","link":"","permalink":"https://linxd1999.github.io/2019/11/16/Git/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"盒子模型","slug":"盒子模型","date":"2019-11-08T15:07:39.591Z","updated":"2019-11-08T15:07:39.591Z","comments":true,"path":"2019/11/08/盒子模型/","link":"","permalink":"https://linxd1999.github.io/2019/11/08/盒子模型/","excerpt":"","text":"一.盒子 CSS处理网页时，认为每个元素都包含在一个不可见的盒子里 我们只要把相应的盒子摆放到网页中相应的位置即可完成对网页的布局 组成： 内容区(content) 内边距(padding) 边框(border) 外边距(margin) 二.边框 width：内容区宽度 height：内容区高度 border-width：边框的宽度 可以分别指定四个边框的宽度(顺时针赋值) 如果指定四个值，则分别设置给上，右，下，左 如果指定三个值，则分别设置给上，左右，下 如果指定两个值，则分别设置给上下，左右 如果指定一个值，则设置给四条边 CSS还提供border-xxx-width，xxx可为top，right，bottom，left border-color：边框的颜色，赋值规则同上 border-xxx-color：xxx可为top，right，bottom，left border-style：边框的样式，赋值规则同上 none：没有边框 solid：实线边框 dotted：点状边框 dashed：虚线边框 double：双线边框 border：边框的简写样式，可同时设置四个边框的样式，且没有任何顺序要求，但是border只能一次性指定四条边，不能分别指定。 border-xxx：可以一次指定一条边的所有属性 三.内边距 内边距指的是盒子的内容区和盒子边框之间的距离，一共有四个方向的内边距 内边距会影响盒子的可见框的大小 盒子可见框的宽度=(border-left-width)+(padding-left)+width+(padding-right)+(border-right-width) padding-top：上内边距的宽度 padding-right：右内边距的宽度 padding-bottom：下内边距的宽度 padding-left：左内边距的宽度 padding可同时设置四个内边距的样式，原理同上 box-sizing属性：border-box(设置的边框和内边距是包含在width内的，内容区的实际宽度=width-(border+padding)的值) 四.外边距 外边距指的是当前盒子与其他盒子之间的距离，不会影响可见框的大小，但会影响盒子的位置 盒子有四个方向的外边距 margin-top：上外边距的宽度 margin-right：右外边距的宽度 margin-bottom：下外边距的宽度 margin-left：左外边距的宽度 margin可同时设置四个方向外边距的样式 由于页面中的元素都是靠左上摆放的，所以当设置上，左外边距时，会导致盒子自身的位置发生改变，设置右，下外边距会改变其他盒子的位置 外边距可以是负值，元素向反方向移动 margin还可以设置auto，一般只设置给水平方向的margin，如果只指定左外边距或右外边距的值为auto则会将外边距设置为最大值；垂直方向如果设置为auto，则默认为0 1234/*盒子居中，两侧外边距设置为相同的值 可以使元素自动在父元素中居中*/margin-left: auto;margin-right: auto; 垂直外边距的重叠：在垂直方向的相邻外边距会发生重叠，兄弟元素之间的相邻外边距会取最大值而不是取和。如果父子元素的垂直外边距相邻了，则子元素的外边距会设置给父元素 浏览器为了在页面中没有样式时，也可以有一个比较好的显示效果，所以为很多元素都设置了默认的margin和padding，而默认样式在正常情况下是不需要的，所以我们需要在设置样式之前把默认样式都去掉 五.内联元素的盒模型 内联元素不能设置width和height 内联元素可以设置水平方向的内边距，边框 内联元素可以设置垂直方向的内边距，边框，但不会影响页面的布局 水平方向的相邻外边距不会重叠，但会求和，内联元素不支持垂直外边距 内联元素和块元素可以相互转换 display样式可修改元素的类型 inline：内联元素 block：块元素 inline-block：行内块元素(使一个元素既有行内元素的特点又有块元素的特点，可设置宽高而不独占一行) none：此元素不显示，且不再占据页面的位置 visibility可修改元素的显示状态 visible：默认值，元素默认在页面显示 hidden：元素会隐藏不显示，但位置会继续保持 overflow属性：设置父元素如何处理子元素溢出的问题 visible：默认值，不对溢出内容做处理，元素会在父元素以外的位置显示 hidden：溢出的内容被修剪，不显示 scroll：会为父元素添加滚动条，通过滚动来查看完整的内容(不论是否溢出，都有水平和垂直的滚动条) auto：会根据需求自动添加滚动条 六.浮动 块元素在文档流中默认垂直排列，如果希望块元素可以脱离文档流，可以用float使块元素浮动从而脱离文档流 float：浮动元素，脱离文档流 none：默认值，元素默认在文档流中排列 left：元素会立即脱离文档流，向页面的左侧浮动 right：元素会立即脱离文档流，向页面的右侧浮动 元素浮动之后，它下边的元素会立即向上移动 元素浮动以后，它会尽量向页面的左上或是右上浮动，直到遇到父元素的边框或者其他的浮动元素 如果浮动元素上边是一个没有浮动的块元素，则浮动元素不会超过块元素 浮动元素不会超过它的兄弟元素，最多一边齐 块元素脱离文档流后，高度和宽度都会被内容撑开 内联元素脱离文档流后会变成块元素 文档流中，父元素的高度默认被子元素撑开。但子元素浮动后，会导致父元素高度塌陷，父元素下的所有元素都向上移动，页面布局混乱 可以将父元素的高度固定，父元素的高度将不能自适应子元素的高度，不推荐使用 设置overflow：(非visible的值) 在高度塌陷的父元素最后添加一个空白的div，由于此div没有浮动，所以可以撑开父元素，然后对它清除左右浮动即可(基本无副作用) 基于上一条，可以通过after伪类，选中父元素的最后边，转化为块元素，再清除浮动 12345.box1:after&#123; content: \"\"; display: block; clear: both;&#125; clear：清除浮动 none：默认值，不清除浮动 left：清除左侧浮动元素对当前元素的影响 right：清除右侧浮动元素对当前元素的影响 both：清除左右浮动元素中对当前元素影响最大的 七.定位 定位是将指定的元素摆放到页面的任意位置，通过定位可以任意的摆放元素 position属性：设置元素的定位 static：默认值，元素没有开启定位 relative：开启元素的相对定位 absolute：开启元素的绝对定位 fixed：开启元素的固定定位(绝对定位的一种) 1.相对定位 position设置成relative时，则开启了元素的相对定位，元素不会脱离文档流，但会使元素提高一个层级，不会改变元素的性质，块还是块，内联还是内联 开启相对定位但不设置偏移量时，元素不会发生任何变化 可以通过left，right，top，bottom四个属性来设置元素的偏移量 left：元素相对于原定位位置的左侧偏移量 right：元素相对于原定位位置的右侧偏移量 top：元素相对于原定位位置的上侧偏移量 bottom：元素相对于原定位位置的下侧偏移量 通常偏移量只需要使用两个就可以对一个元素进行定位，一般选择水平方向的一个偏移量和垂直方向的偏移量来为一个元素进行定位 2.绝对定位 positon设置成absolute时，开启元素的绝对定位，元素会脱离文档流 开启绝对定位但不设置偏移量时，元素位置不变 绝对定位是相对于离他最近的开启了定位的祖先元素进行定位，如果所有的祖先元素都没有开启定位，则相对于浏览器窗口进行定位(一般情况下，开启了子元素的绝对定位都会同时开启父元素的相对定位) 绝对定位会使元素提升一个层级 绝对定位会改变元素的性质，内联元素变成块元素 3.固定定位 position设置为fixed时，开启元素的固定定位 固定定位也是一种绝对定位，大部分特点和绝对定位一样，但有一些不同 固定定位永远相对于浏览器窗口进行定位 固定定位会固定在浏览器窗口的某个位置，不会随滚动条滚动(牛皮癣广告) IE6不支持固定定位 4.元素层级 如果定位元素的层级一样，则下边的元素会盖住上边的 通过z-index属性可设置元素的层级(数字越大，层级越大，越优先显示) 对于没有开启定位的元素不能使用z-index属性 5.透明背景 opacity属性：设置背景的透明度，值为0-1 0表示完全透明 0.5表示半透明 1表示完全不透明 opacity在IE8以下的浏览器不支持，需要用alpha(opacity=透明度)代替 需要一个0-100之间的值 0表示完全透明 100表示完全不透明 50表示半透明 八.背景 background-image：设置背景图片 语法：background-image：url(“相对路径”) 如果背景图片大于元素，默认会显示图片的左上角 如果背景图片和元素一样大，则会将背景图片全部显示 如果背景图片小于元素，则平铺图片充满元素 一般设置背景图片时都会同时指定一个背景颜色 background-repeat：设置背景图片的重复方式 repeat：默认值，背景图片平铺 no-repeat：背景图片不会重复 repeat-x：背景图片沿水平方向重复 repeat-y：背景图片沿竖直方向重复 background-position：背景图片默认贴着左上角，这个属性可以调整图片在元素中的位置 该属性可以使用top，left，right，bottom，center中的两个值来指定位置 top left：左上，默认 bottom right：右下 缺省值会被指定为center 也可以指定两个偏移量：xpos，ypos，正数向右(下)移动，负数向左(上)移动 background-attachment：设置图片是否随页面一起滚动 scroll：默认值，背景图片会随着窗口滚动 fixed：背景图片会固定在某一个位置，不随页面滚动，一般都是设置body中的大图片；设置在块元素中的图片也不会随页面滚动，但是块元素会随着页面滚动，所以会出现擦黑板一样的效果(背景图片的定位永远相对于浏览器的窗口)，所以不随窗口滚动的图片一般设置给body，而不设置给其他元素。 background：设置所有的背景图片属性 没有顺序和数量的要求 没写的样式就使用默认样式，注意覆盖 九.CSS-sprite 用不同图片表示一个按钮的不同状态时，第一次切换图片时，会发现有个非常快的闪烁，会造成一次不良的用户体验 产生原因：背景图片是以外部资源的形式加载进网页的，浏览器每加载一个外部资源就需要单独发送一次http请求；外部资源并不是同时加载，浏览器会在资源被使用的时候才去加载外部资源，由于加载图片需要一定的时间，所以在加载和显示的过程中有一段时间，背景图片无法显示，所以才会出现闪烁的情况 解决方法：可以将多张图片整合为一张图片，这样可以几张图片一起加载，就不会产生闪烁的问题了；然后通过background-position来切换要显示的图片位置，这种技术叫做图片整合技术(CSS-sprite，精灵图，雪碧图) 优点 浏览器只要发送一次加载请求就可以同时加载多个图片，提高请求的速度，增加用户体验 多张图片整合成一张，减少图片的总大小，提高请求的速度 十.表格1.表格标签 使用table标签创建表格 tr创建表格中的一行，在tr中用td创建单元格 th创建表格的头部，有默认加粗和居中的样式 rowspan用来设置纵向单元格的合并，colspan用来设置横向单元格的合并 2.表格样式","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://linxd1999.github.io/tags/CSS/"}]},{"title":"Css","slug":"CSS","date":"2019-11-06T14:29:43.423Z","updated":"2019-11-06T14:29:43.423Z","comments":true,"path":"2019/11/06/CSS/","link":"","permalink":"https://linxd1999.github.io/2019/11/06/CSS/","excerpt":"","text":"一.CSS 层叠样式表(Cascading Style Sheets) 可为网页的多层结构创建样式表，从而装饰网页 层叠意味着网页是分层结构，层次高的覆盖层次低的 二.样式表1.内联样式表 可将css样式写到元素的style属性中，只对当前元素起作用，不方便复用和后期维护 2.内部样式表 将style标签写到head标签中，可改变该文件中的样式，但不方便应用于多个文件 3.外部样式表 将样式表写到一个单独的.css文件中，如果某个文件要使用css样式，需要link标签引用 1&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"&gt; 完全使结构和表现分离，使样式表可在不同页面中使用，最大限度的复用了样式表，可以利用浏览器的缓存，加快用户访问速度，提高用户体验。 开发中最推荐使用外部css文件 在CSS中，祖先元素上的样式，会被后代元素所继承，利用继承可把一些基本的样式设置给祖先元素，这样所有的后代元素都将会自动继承这些样式 但不是所有样式都会被继承，背景相关，边框相关，定位相关的样式都不会被继承，否则会带来样式混乱的后果 三.语法1.注释 /**/ 2.选择器 选中页面中指定的元素，并且将声明块中样式应用到选择器对应的元素上 1.元素选择器 可以选择某种单独的元素设置样式 2.id选择器 对某个元素设置id属性，可以做到选中某种元素中带id的元素，用#标识 不建议用复合选择器 3.类选择器 对某个元素设置class属性，可以把几个元素分为一组来设置样式，用.标识 4.并集选择器 对几个选择器进行合并，可以同时操作更多不同的标签，用” , “分开 5.交集选择器 可以选中同时满足多个选择器的元素设置样式 6.通配选择器 可以选中页面内的所有元素，用” * “标识 7.后代选择器 语法：祖先元素 后代元素{ } 可选中某个特定祖先元素的某后代元素 8.子元素选择器 语法：父元素&gt;子元素 可选中指定父元素的子元素 9.伪类选择器 用来表示元素的一种特殊的状态 例如：访问过的超链接，获取焦点的文本框 链接样式：a:link(正常链接)，a:visited(访问过的链接)，a:hovor(鼠标滑过的链接)，a:active(正在点击的链接) hover和active也可以为其他元素设置样式 其他伪类选择器：input:focus(获取焦点)，p::selection(选中文本) 123456789101112131415a:link&#123; color: red; &#125; a:visited&#123; color: yellow; &#125; a:hover&#123; color: aqua; &#125; a:active&#123; color: black; &#125; p:active&#123; color: red; &#125; link，visited，hover，active优先级相同，但有顺序的区别。hover如果放active后面，则active被覆盖而失效，link，visited也必须放在hover，active前面，原因同理。 10.伪元素 CSS 在渲染文档的时候，伪元素可以通过 css 给 HTML 添加一个元素（叫标签也行），这个元素在文档树中是找不到的。 常见的有 :before(表示元素最前边的部分)，:after(表示元素最后边的部分)，:first-letter(选中第一个字母)，:first-line(选中元素的第一行) 11.属性选择器 title属性：这个标签可以给任何标签指定，当鼠标移到元素上时，title属性的值将会作为提示文字显示 作用：可以根据元素中的属性或属性值来选取指定元素 语法： [属性名] 选取含有指定属性的元素 [属性名=”属性值”] 选取含有指定属性值的属性 [属性名^=”属性值”] 选取以属性值以指定内容开头的元素 [属性名$=”属性值”] 选取以属性值以指定内容结尾的元素 [属性名*=”属性值”] 选取以属性值包含指定内容的元素 12.子元素的伪类 :first-child：选中第一个子元素 :last-child：选中最后一个子元素 :nth-child：选中任意位置的子元素，该选择器后面可以指定一个参数，指定要选中第几个子元素 even表示偶数位置的子元素 odd表示奇数位置的子元素 first-of-type，last-of-type，nth-of-type和上面三个非常类似，只不过child是在所有子元素里排列，type是在当前类型的子元素中排列 13.兄弟元素选择器 span+p：选中span后一个紧挨着的p元素 span~p：选中span后所有的p元素 14.否定伪类 可以从已选中的元素中剔除某些元素 语法：:not(选择器) 15.选择器的优先级 不同选择器选中同一个元素并且设置相同样式时，优先级高的选择器优先设置样式 规则： 内联样式：优先级1000 id选择器：优先级100 类和伪类：优先级10 元素选择器：优先级1 通配选择器：优先级0 继承的样式：无优先级 选择器中包含多个选择器时(交集选择器)，优先级相加再比较，但是和不会超过他的最大数量级 如果选择器优先级一样，则使用靠后的样式(覆盖) 并集选择器的优先级单独计算 样式最后可添加 !important，此时该样式的优先级会超越内联样式，但尽量避免使用 3.声明块 声明块紧跟选择器后边，用一对{}括起来 实际上就是名值对结构，一个声明块中可写多个声明，声明之间用;隔开，名值之间用:隔开 四.块元素和内联元素1.块元素 会独占一行的元素，无论内容多少，都会占一行 块元素主要用来对页面做布局 div元素：没有任何语义，是一个纯粹的块元素，不会为里面的内容设置任何默认样式 div元素主要用来对页面进行布局 a元素可以包含任何元素，但不能包含本身 p元素不可以包含任何其他的块元素 2.内联元素(行内元素) 不会占用一整行，只会占用自身大小 内联元素主要用来选中文本设置样式 span元素：本身没有任何语义，用来选中文字来设置样式 一般用块元素包含内联元素 五.文本1.文本标签 cite标签：参考的内容，如书名，歌名，话剧名，电影名等 small标签：内容比父元素中的文字小一些 p标签：短引用，内联引用 blockquote：长引用，块引用 sup标签：设置上标(superscript) sub标签：设置下标(subscript) del标签：删除的内容(划掉) ins标签：插入的内容(下划线) code标签：专门表示代码 pre标签：预格式标签，会将代码中的格式保存，不会忽略空格(一般结合pre和code表示一段代码) ul标签：无序列表 ol标签：有序列表 li标签：列表项 有序无序列表都可以改type属性来修改项目符号，但一般不使用，可用为li设置背景图片的方法来设置 ul，ol，li都是块元素 可互相嵌套 dl标签：定义列表，子标签dt：被定义的内容；dd：对定义内容的描述 2.文本样式 text-transform：设置文本大小写 none：默认值 capitalize：单词首字母大写，通过空格来识别单词 uppercase：所有字母大写 lowercase：所有字母小写 text-decoration：设置文本的修饰 none：默认值 underline：下划线 overline：上划线 line-through：删除线 超链接默认添加下划线，也就是text-decoration默认值为underline letter-spacing：字符间距 word-spacing：单词间距 text-align：设置文本对齐 left：靠左对齐 right：靠右对齐 center：居中对齐 justify：两端对齐(调整文本之间的空格) text-indent：设置首行缩进 指定一个正值时，会自动向右缩进指定的像素；指定一个负值，向左移动指定的像素，可以将一些不想显示的文字隐藏起来。 text-indent: 2em表示首行缩进两个字符，会根据字体大小变化而变化。 六.长度单位 像素px(pixel)：使用最多的单位，一个像素相当于屏幕上的一个小点，但这些像素点是不能被直接看见的。不同显示器的一个像素大小不同，显示效果越好，像素就越小。 百分比%：浏览器会根据父元素的样式来计算该值。好处在于父元素属性值变化时，子元素会随之改变，在创建自适应页面时，常使用百分比作为单位 em：和百分比类似，是相对于当前元素的字体大小来计算的，1em=1font-size(当前元素的字体大小)。使用em时，当字体大小发生改变时，em也会随之改变，当设置字体相关样式时会经常使用em 七.颜色单位 可直接用颜色的单词来表示不同的颜色 可用RGB值来表示不同的颜色 Red，Green，Blue三原色，通过三种颜色的不同浓度来表示不同的颜色 rgb(红色的浓度，绿色的浓度，蓝色的浓度) 颜色的浓度是一个0-255之间的值，255表示最大，0表示没有，也可用百分比 可用十六进制的rgb值来表示颜色，原理同上 语法：#红色绿色蓝色 00表示没有，ff表示255 两位重复数字可简写成一个数字 八.字体 color：字体颜色 font-size：设置的并不是字体大小，在页面中，每个文字都处于一个看不见的框中，font-size实际上设置的是格子的高度。一般情况下文字都要比格小一些，有时候也会比格大。根据字体的不同，显示效果也不同 font-family：指定文字字体 浏览器支持则使用，不支持则使用默认字体 可同时指定多个字体，用逗号分隔，优先使用前面的字体，如果没有或设置不了再尝试下一个 字体分为5大类：serif(衬线字体)，sans-serif(非衬线字体)，monospace(等宽字体)，cursive(草书)，fantasy(虚幻字体)，前两个很长用，一般放设置字体的最后兜底 font-style：可用来设置文字斜体 normal：文字正常 italic：文字斜体显示 oblique：文字倾斜，效果和italic一样，一般用italic font-weight：可显示文字的加粗效果 normal：正常粗细 bold：文字加粗显示 font-variant：设置小型大写字母 normal：正常字体 small-caps：小型大写字母 font：可同时设置字体相关的所有样式，用空格分开 斜体，加粗，小大字母，没有顺序要求，可写可不写，不写使用默认值 文字的大小和字体必须写，而且字体必须是最后一个样式，大小必须是倒数第二个样式 性能较好 九.行高 line-height：间接设置行间距，行间距=行高-字体大小 接收值： 直接接收一个大小 指定一个百分数，会相对字体去计算 接收一个数，则行高会设置字体大小相应的倍数 对于单行文本来说，可以将行高设置成和父元素一致，可以使单行文本在父元素中垂直居中 在font属性中可以指定行高，在字体大小后可以添加 / 行高，来指定行高，该值可选，如果不指定则会使用默认值 12345p&#123; /*前一行不生效，行高被后一行的默认值覆盖*/ line-height: 40px; font: 30px \"微软雅黑\"; &#125;","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://linxd1999.github.io/tags/CSS/"}]},{"title":"模拟函数栈实现非递归遍历二叉树","slug":"树的遍历","date":"2019-09-28T07:57:53.543Z","updated":"2019-09-28T07:57:53.543Z","comments":true,"path":"2019/09/28/树的遍历/","link":"","permalink":"https://linxd1999.github.io/2019/09/28/树的遍历/","excerpt":"","text":"一.思想 递归实现的遍历是基于函数栈的不断返回完成的，所以我们也可以用栈这个数据结构来模拟这种函数栈的返回 这种方法可以实现前序，中序，后序遍历写出基本一致的代码，只不过入栈顺序不同 使用颜色标记节点状态，新节点为白色，访问过的节点为灰色。白色意味着继续递归，灰色意味着在函数栈返回时可将该节点存入结果集中 栈顶节点为白色，则将其标记为灰色，然后将其自身，左子节点，右子结点按指定顺序依次入栈 栈顶节点为灰色，则将节点的值输出 例如前序遍历：前序遍历的顺序是根左右，所以入栈顺序就应该是右左根(基于栈的先进后出原则) 参考：力扣题解 代码：代码仓库 二.实现代码 前序遍历 123456789101112131415161718192021222324252627282930class Solution &#123; public enum color&#123; White,Grey; &#125; class isRecursion&#123; color c; TreeNode n; public isRecursion(color c,TreeNode n) &#123; this.c = c; this.n = n; &#125; &#125; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); Stack&lt;isRecursion&gt; s = new Stack&lt;&gt;(); s.push(new isRecursion(color.White,root)); while(!s.isEmpty()) &#123; isRecursion temp = s.pop(); if(temp.n == null) continue; if(temp.c == color.White) &#123; if(temp.n.right != null) s.push(new isRecursion(color.White,temp.n.right)); if(temp.n.left != null) s.push(new isRecursion(color.White,temp.n.left)); s.push(new isRecursion(color.Grey,temp.n)); &#125;else &#123; res.add(temp.n.val); &#125; &#125; return res; &#125;&#125; 中序遍历 123456789101112131415161718192021222324252627282930class Solution &#123; public enum color&#123; White,Grey; &#125; class isRecursion&#123; color c; TreeNode n; public isRecursion(color c,TreeNode n) &#123; this.c = c; this.n = n; &#125; &#125; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); Stack&lt;isRecursion&gt; s = new Stack&lt;&gt;(); s.push(new isRecursion(color.White,root)); while(!s.isEmpty()) &#123; isRecursion temp = s.pop(); if(temp.n == null) continue; if(temp.c == color.White) &#123; if(temp.n.right != null) s.push(new isRecursion(color.White,temp.n.right)); s.push(new isRecursion(color.Grey,temp.n)); if(temp.n.left != null) s.push(new isRecursion(color.White,temp.n.left)); &#125;else &#123; res.add(temp.n.val); &#125; &#125; return res; &#125;&#125; 后序遍历 123456789101112131415161718192021222324252627282930class Solution &#123; public enum color&#123; White,Grey; &#125; class isRecursion&#123; color c; TreeNode n; public isRecursion(color c,TreeNode n) &#123; this.c = c; this.n = n; &#125; &#125; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); Stack&lt;isRecursion&gt; s = new Stack&lt;&gt;(); s.push(new isRecursion(color.White,root)); while(!s.isEmpty()) &#123; isRecursion temp = s.pop(); if(temp.n == null) continue; if(temp.c == color.White) &#123; s.push(new isRecursion(color.Grey,temp.n)); if(temp.n.right != null) s.push(new isRecursion(color.White,temp.n.right)); if(temp.n.left != null) s.push(new isRecursion(color.White,temp.n.left)); &#125;else &#123; res.add(temp.n.val); &#125; &#125; return res; &#125;&#125;","categories":[],"tags":[{"name":"Tree","slug":"Tree","permalink":"https://linxd1999.github.io/tags/Tree/"}]},{"title":"","slug":"HTML","date":"2019-09-21T12:59:48.262Z","updated":"2019-09-21T12:59:48.262Z","comments":true,"path":"2019/09/21/HTML/","link":"","permalink":"https://linxd1999.github.io/2019/09/21/HTML/","excerpt":"","text":"HTML链接 a标签： 文本链接、图片链接 属性： href：指向另一个文档的链接 name：创建文档内的链接（锚点链接：指向同一个页面内另一处文本段落的链接） img标签属性： alt：替换文本属性 width：宽(px) height：高(px) HTML表格 table标签： 属性： 边框：border 内间距：cellpadding 侧边距：cellspacing 背景颜色：bgcolor 背景图片：background ：单元格 ：表格行 HTML列表 无序列表：使用标签、 属性：(type)disc、circle、square 有序列表：使用标签、 属性：(type)A、a、I、i 嵌套列表：使用标签、、 自定义列表：、、 HTML块 块元素：显示时以新行开始 如、、 内联元素：通常不从新行开始 如、、 div元素：组合html元素的容器，为大块内容提供结构和背景，其中所含元素的特性由div标签的属性来控制 span元素：内联元素，可做文本容器，一般用于改部分文本的样式 div,section,article元素 这三个都是针对一块区域做布局的标签 语义逐渐增强，可嵌套 div本身无语义，用作布局及css样式化 section用作一段有专题性的内容， 里面基本上会带有标题 article用作一段独立的，完整的内容块 nav元素 页面导航的链接组 传统导航条，侧边栏导航，页内导航，翻页操作","categories":[],"tags":[]},{"title":"排序算法","slug":"排序","date":"2019-09-19T02:11:38.838Z","updated":"2019-09-19T02:11:38.838Z","comments":true,"path":"2019/09/19/排序/","link":"","permalink":"https://linxd1999.github.io/2019/09/19/排序/","excerpt":"","text":"一.冒泡排序 冒泡排序实质上就是让相邻两个数比较，较大数向右走，每轮可以确定一个最大的数 123456789101112131415161718192021222324252627public class BubbleSort &#123; public static void main(String[] args) &#123; int arr[] = &#123;3,9,-1,10,-2&#125;; bubbleSort(arr); System.out.println(Arrays.toString(arr)); &#125; public static void bubbleSort(int []arr) &#123; int temp = 0; boolean f = false; //冒泡排序的时间复杂度:O(n^2) for(int i = 0; i &lt; arr.length-1; i++) &#123; for(int j = 0; j &lt; arr.length-1-i; j++) &#123; if(arr[j]&gt;arr[j+1]) &#123; f = true; temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; if(f == false) &#123; break; &#125;else &#123; f = false; &#125; &#125; &#125;&#125; 二.选择排序 选择排序的实质就是每轮选出一个最小的数放到数组的最前面 1234567891011121314151617181920212223public class SelectSort &#123; public static void main(String[] args) &#123; int arr[] = &#123;3,9,-1,10,-2&#125;; selectSort(arr); System.out.println(Arrays.toString(arr)); &#125; public static void selectSort(int []arr) &#123; for(int i = 0; i &lt; arr.length-1; i++) &#123; int min = arr[i]; int minIndex = i; for(int j = i+1;j&lt;arr.length; j++) &#123; if(min &gt; arr[j]) &#123; min = arr[j]; minIndex = j; &#125; &#125; if(minIndex != i) &#123; arr[minIndex] = arr[i]; arr[i] = min; &#125; &#125; &#125;&#125; 三.插入排序 插入排序就是把数组分成一个无序表和一个有序表，第一个有序表是第一个元素，然后每轮把后一个元素插入合适的位置使整个数组都变为有序表 123456789101112131415161718192021222324public class InsertSort &#123; public static void main(String[] args) &#123; int arr[] = &#123;3,9,-1,10,-2&#125;; insertSort(arr); System.out.println(Arrays.toString(arr)); &#125; public static void insertSort(int [] arr) &#123; int insertVal = 0; int insertIndex = 0; for(int i = 1; i &lt; arr.length; i++) &#123; insertVal = arr[i]; insertIndex = i-1;// 给insertVal找插入的位置 while(insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) &#123; arr[insertIndex+1] = arr[insertIndex]; insertIndex--; &#125; //当退出循环时，插入位置找到,insertIndex+1 if(insertIndex+1 != i) &#123; arr[insertIndex+1] = insertVal; &#125; &#125; &#125;&#125; 四.希尔排序 插入排序中，小的数如果在很后面的话，每次都要移动很长的距离 所以为了解决这个问题，希尔排序使用了一种增量，每次排序都在宏观上把小数往前移，可以使较小的数都出现在数组前部，然后每轮缩小增量直至增量为1。 分为交换式和移位式，移位式效率更高。 12345678910111213141516171819202122232425262728293031323334353637383940414243public class ShellSort &#123; public static void main(String[] args) &#123; int arr[] = &#123; 8, 9, 1, 7, 2, 3, 5, 4, 6, 0 &#125;; //shellSort1(arr); //shellSort2(arr); &#125; // 交换式 public static void shellSort1(int[] arr) &#123; int temp = 0; for (int gap = arr.length / 2; gap &gt; 0; gap /= 2) &#123; for (int i = gap; i &lt; arr.length; i++) &#123; for (int j = i - gap; j &gt;= 0; j -= gap) &#123; if (arr[j] &gt; arr[j + gap]) &#123; temp = arr[j]; arr[j] = arr[gap + j]; arr[gap + j] = temp; &#125; &#125; &#125; System.out.println(Arrays.toString(arr)); &#125; &#125; // 移位式 public static void shellSort2(int[] arr) &#123; int temp = 0; for (int gap = arr.length / 2; gap &gt; 0; gap /= 2) &#123; for (int i = gap; i &lt; arr.length; i++) &#123; int j = i; temp = arr[i]; if (arr[j] &lt; arr[j - gap]) &#123; while (j - gap &gt;= 0 &amp;&amp; temp &lt; arr[j - gap]) &#123; arr[j] = arr[j - gap]; j -= gap; &#125; arr[j] = temp; &#125; &#125; System.out.println(Arrays.toString(arr)); &#125; &#125;&#125;","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://linxd1999.github.io/tags/Algorithm/"}]},{"title":"","slug":"Collection集合","date":"2019-09-04T14:01:18.674Z","updated":"2019-09-04T14:01:18.674Z","comments":true,"path":"2019/09/04/Collection集合/","link":"","permalink":"https://linxd1999.github.io/2019/09/04/Collection集合/","excerpt":"","text":"Collection集合 集合中只能保存对象的引用变量 List子接口：有序，可重复集合(ArrayList、LinkedList、Vector) Set子接口：无序，不可重复集合(HashSet、LinkedHashSet、TreeSet) Queue子接口：先进先出队列 Lambda表达式遍历集合 Connection接口继承了Iterable接口 Java8新增了一个forEach(Consumer action)方法，参数是消费者(函数式接口) 程序将元素依次传给Consumer的accept()，该方法是接口中唯一的抽象方法 12345List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(\"hello\");list.add(\"world\");list.add(\"java\");list.forEach(obj-&gt;System.out.println(obj)); 类似，Iterator的forEachRemaining(Consumer action)同样可以使用lambda表达式遍历迭代器 1it.forEachRemaining(obj-&gt;System.out.println(obj)); List集合 特点：有序、可重复 新增方法： 12345678910111213List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(\"hello\");list.add(\"world\");list.add(\"java\");//在指定位置添加指定元素list.add(1, \"a\");//删除指定位置元素，返回被删除的元素System.out.println(list.remove(2));//修改指定位置的元素，返回被修改的元素System.out.println(list.set(2, \"javase\"));//返回指定索引处的元素System.out.println(list.get(2));System.out.println(list); 并发修改异常(ConcurrentModificationException) 产生原因：迭代器遍历过程中，通过集合对象修改了集合中元素的长度导致的迭代器获取元素中预期修改值和实际修改值不一致 解决：用for循环替代迭代遍历，用get()获取元素 ListIterator List特有的迭代器 可从任一方向遍历集合 新增add()方法，且底层经过优化，在迭代遍历中用迭代器增加集合内的元素不会抛出并发修改异常。 1234while(it.hasPrevious()) &#123; String s = (String)it.previous(); System.out.println(s);&#125; 增强for循环实际上还是Iterator，迭代时也不能修改元素长度 LinkedList集合 特有方法： 123456public void addFirst(E e)public void addLast(E e)public E getFirst()public E getLast()public E removeFirst()public E removeLast() Set集合 特点：无序，不可重复 没有带索引的方法，不能用普通for循环遍历 哈希值：JDK根据对象的地址或者字符串或者数字算出来的int值 同一个对象多次调用hashCode()方法返回相同哈希值 默认情况下，不同对象的哈希值不同，可通过重写hashCode()方法，可以实现让不同对象的哈希值相同 HashSet集合 底层数据结构是HashMap，由数组和链表构成 存取顺序不做保证 保证元素唯一性：存入元素和以前元素比较哈希值 如果哈希值不同，继续执行，把元素添加入集合 如果哈希值相同，调用equals()方法比较 返回false，继续执行，把元素添加到集合 返回true，说明元素重复，不存储 要保证元素唯一性，需要重写hashCode()和equals() LinkedHashSet 哈希表和链表构成，元素有次序 元素不可重复 TreeSet 元素会按照一定的规则排序，取决于构造方法 TreeSet()：自然排序 TreeSet(Comparator comparator)：根据指定的比较器进行排序 自然排序Comparable 元素所属类实现Comparable接口，重写compareTo(T o)方法 重写方法必须注意按照要求的主要和次要条件来写 compareTo()方法有this，this在前面表示升序 123456789101112131415161718192021222324252627282930313233343536373839import java.util.TreeSet;public class TreeSetDemo &#123; public static void main(String[] args) &#123; TreeSet&lt;Student&gt; ts = new TreeSet&lt;&gt;(); Student s1 = new Student(\"a\",29); Student s2 = new Student(\"c\",28); Student s3 = new Student(\"d\",30); Student s4 = new Student(\"b\",33); Student s5 = new Student(\"c\",33); ts.add(s1); ts.add(s2); ts.add(s3); ts.add(s4); ts.add(s5); ts.forEach(obj-&gt;System.out.println(obj.getName()+\" \"+obj.getAge())); &#125;&#125;class Student implements Comparable&lt;Student&gt;&#123; private String name; private int age; public Student(String name,int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; @Override public int compareTo(Student o) &#123; int num = this.age-o.age; int num2 = num==0 ? this.name.compareTo(o.name) : num; return num2; &#125;&#125; 比较器排序Comparator 重写Comparator的compare(T o1,T o2)方法 123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.*;public class TreeSetDemo &#123; public static void main(String[] args) &#123; TreeSet&lt;Student&gt; ts = new TreeSet&lt;&gt;(new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; int num = o1.getAge()-o2.getAge(); int num2 = num==0 ? o1.getName().compareTo(o2.getName()) : num; return num2; &#125; &#125;); Student s1 = new Student(\"a\",29); Student s2 = new Student(\"c\",28); Student s3 = new Student(\"d\",30); Student s4 = new Student(\"b\",33); Student s5 = new Student(\"c\",33); ts.add(s1); ts.add(s2); ts.add(s3); ts.add(s4); ts.add(s5); ts.forEach(obj-&gt;System.out.println(obj.getName()+\" \"+obj.getAge())); &#125;&#125;class Student&#123; private String name; private int age; public Student(String name,int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125;&#125; Map集合 将键映射到值的对象，不能包含重复键，键可以映射最多一个值 添加元素时，如果键一样，值会被覆盖","categories":[],"tags":[]},{"title":"String、StringBuffer、StringBuilder类","slug":"String、StringBuffer、StringBuilder类","date":"2019-08-30T15:12:26.564Z","updated":"2019-08-30T15:12:26.564Z","comments":true,"path":"2019/08/30/String、StringBuffer、StringBuilder类/","link":"","permalink":"https://linxd1999.github.io/2019/08/30/String、StringBuffer、StringBuilder类/","excerpt":"","text":"一.字符串常量池字符串常量池属于Java的静态常量池，即.class文件中的常量池，占用class文件的大部分空间，还保存一些类、方法、接口中的常量。 String.intern()方法：查找常量池中是否存在该字符串，若存在则返回字符串的引用，若不存在则把该字符串添加进常量池并返回引用。 “abc”和new String(“abc”)的区别 在编译时候就能计算出的字符串值，JVM用常量池管理这些字符串 new一个字符串时，先用常量池管理该字符串，然后再用构造器创建一个新String对象，保存在堆内存中，共产生两个对象 常量池保证相同的字符串直接量只有一个，可以多个引用指向同一个常量。 常量池避免频繁创建销毁对象，实现对象共享，节省内存和运行时间。 12345678910String s1 = \"abc\";String s2 = \"ab\" + \"c\";String s3 = \"ab\";String s4 = \"c\";String s5 = s3 + s4;String s6 = new String(\"abc\");System.out.println(s1 == s2);//trueSystem.out.println(s1 == s5);//falseSystem.out.println(s1 == s5.intern());//trueSystem.out.println(s1 == s6);//false ==表示比较两个引用变量指向的地址。 s1 == s2：编译器会在编译期间自动把已知字符串拼接好，并放入常量池 s1 != s5：s5不能在编译期间确定，地址不能确定 s1 == s5.intern()：intern方法检测出s5内容存在于常量池中，返回字符串引用 s1 != s6：构造器生成的字符串编译时地址不能确定 二.StringBuffer和StringBuilderStringBuffer对象是一个字符序列可变的字符串 StringBuilder是JDK1.5之后新增的类，操作和StringBuffer基本一样 这两个类都解决了大量拼接字符串时产生很多中间对象而影响性能的问题 区别：StringBuffer线程安全，效率低；StringBuilder线程不安全，效率高，所以StringBuilder使用的多，尤其是单线程应用。 123456789101112131415StringBuilder sb = new StringBuilder();for(int i = 0; i &lt; 26; i++) &#123; sb.append((char)('a'+i));&#125;System.out.println(sb);//abcdefghijklmnopqrstuvwxyzSystem.out.println(sb.hashCode());//664740647sb.reverse();System.out.println(sb);//zyxwvutsrqponmlkjihgfedcbaSystem.out.println(sb.hashCode());//664740647sb.setCharAt(0, 'A');System.out.println(sb);//Ayxwvutsrqponmlkjihgfedcbasb.insert(1, \"bcd\");System.out.println(sb);//Abcdyxwvutsrqponmlkjihgfedcbasb.delete(0, 4);System.out.println(sb);//yxwvutsrqponmlkjihgfedcba 几个常用方法： append()：追加 reverse()：倒序 setCharAt()：修改某位置字符 setLength()：设置字符串长度 insert()：在某位置添加字符或字符串 delete()：删除某位置的字符","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://linxd1999.github.io/tags/Java/"}]},{"title":"面向对象(类、继承、多态)","slug":"面向对象(类、继承、多态)","date":"2019-08-24T16:46:55.613Z","updated":"2019-08-24T16:46:55.613Z","comments":true,"path":"2019/08/25/面向对象(类、继承、多态)/","link":"","permalink":"https://linxd1999.github.io/2019/08/25/面向对象(类、继承、多态)/","excerpt":"","text":"一. 类、对象、引用、指针1.引用变量及内存分析众所周知Java没有指针，但实际上Java的引用就相当于指针，只不过把这个指针封装起来，避免其繁琐的操作。 例如Person p = new Person()，这行代码创建了一个实例，实际上，p作为一个引用变量(只存放对象地址)存放在调用这行代码的方法栈中，而Person作为一个对象被存放在堆内存中，然后引用变量p指向堆里的Person。Java程序不允许直接访问堆内对象，只能通过引用变量来访问。若堆内的对象没有任何引用变量指向它，则这个对象会被GC回收，反之，若想让GC回收某对象，只需要切断所有引用变量跟这个对象的联系即可。 2.this关键字this关键字总是指向调用该方法的对象，其最大的作用就是让类里的一个方法调用类里的另外一个方法或者实例变量。 Java允许对象的一个成员直接调用另一个成员可以忽略this前缀。 3.static关键字static关键字的真正作用：区分成员变量，方法，内部类是属于类本身还是属于类的实例 有static修饰的成员属于类本身，没有static修饰的成员属于类的实例。 因为static成员属于类本身，所以调用static成员是什么实例并不明确，所以不能在static方法内使用this关键字、super关键字。 方法以this作为返回值：可以在一行代码中多次连续调用该方法。 4.参数传递机制1234567891011121314151617 public class Swap &#123; int a,b; public Swap(int a,int b) &#123; this.a = a; this.b = b; &#125; public static void swap(Swap temp) &#123; int tmp = temp.a; temp.a = temp.b; temp.b = tmp; &#125; public static void main(String args[]) &#123; Swap s = new Swap(3,4); swap(s); System.out.println(s.a+\" \"+s.b); &#125;&#125; 首先在main函数内，main函数的栈内存放了引用变量s，指向堆内存的对象Swap；swap函数传入一个形参temp也指向堆内存里的Swap对象。所以两个引用变量都指向堆内存中的对象，只要操作一个引用变量，堆内存中对象的数据就会改变，所以数据交换可以成功。 5.成员变量、局部变量成员变量：不被static修饰的实例变量，被static修饰的类变量 局部变量：形参，方法中的变量，代码块中的变量 6.访问控制符private：当前类访问权限 default：包访问权限，可被相同包下的其他类访问 protected：子类访问权限，可被不同包中的子类访问 public：公共访问权限，可被所有类访问","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://linxd1999.github.io/tags/Java/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2019-08-09T17:17:13.445Z","updated":"2019-08-09T17:17:13.445Z","comments":true,"path":"2019/08/10/正则表达式/","link":"","permalink":"https://linxd1999.github.io/2019/08/10/正则表达式/","excerpt":"","text":"一、定义和规则 定义：正则表达式是一个非常强大的字符串处理工具，能对字符串进行查找，提取，分割，替换等操作 常用的正则表达式支持字符 裸字符：除了特殊字符，都可以直接匹配 \\uhhhh：Unicode万国码 ()：标记子表达式的位置 []：枚举或范围 {}：字符的出现频率 *：前面子表达式可以出现0或多次，相当于{0,} +：前面子表达式可以出现1或多次，相当于{1,} ?：前面子表达式可以出现0或1次，相当于{0,1} . ：匹配所有除了换行以外的字符 |：或 d是digit，s是space，w是word \\d：匹配0-9的所有数字，\\D是其补集 \\s：匹配空白字符，包括空格，回车，制表，换页等，\\S是其补集 \\w：匹配所有单词字符，包含数字，英文字母，下划线，\\W是其补集 -：范围符 [^]：求否 二、使用需要使用Pattern类和Matcher类 import java.util.regex.Matcher;import java.util.regex.Pattern; Pattern对象是正则表达式编译后在内存中的表示形式，多个Matcher对象可以共享一个Pattern对象 Matcher是匹配器，需要调用Pattern的matcher()结果来执行匹配 常用方法如下： find()：是否包含与正则表达式匹配的子串 group()：返回上一次匹配的子串 start()：返回上一次匹配的子串起始位置 end()：返回上一次匹配的子串结束位置+1 matches()：整个目标字符串与正则表达式是否匹配 reset()：重置匹配器，并可以启用新的需要匹配的字符串 例1：分离字符串中的整数 1234Matcher m = Pattern.compile(\"\\\\d+\").matcher(\"&lt;10|100&gt;\");while(m.find()) &#123; System.out.println(m.group());&#125; 例2：判断邮箱正确性 1234567891011121314151617String [] mails = &#123; \"lxd1999@qq.com\", \"lxd1999@163.com\", \"lxd1999@gmail.cn\", \"as@qq.ws\"&#125;;String RegEx = \"\\\\w&#123;3,20&#125;@\\\\w+\\\\.(com|cn)\";Pattern p = Pattern.compile(RegEx);Matcher m = null;for(String temp : mails) &#123; if(m==null) &#123; m = p.matcher(temp); &#125;else &#123; m.reset(temp); &#125; System.out.println(temp+(m.matches()?\"是\":\"不是\")+\"一个有效的邮件地址\"); &#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://linxd1999.github.io/tags/Java/"}]},{"title":"JDBC编程","slug":"jdbc","date":"2019-07-16T07:52:13.869Z","updated":"2019-07-16T07:52:13.869Z","comments":true,"path":"2019/07/16/jdbc/","link":"","permalink":"https://linxd1999.github.io/2019/07/16/jdbc/","excerpt":"","text":"一、JDBC简介JDBC(Java Database Connectivity):JAVA数据库连接，是可以执行sql语句的一套API 程序可通过JDBC连接到关系数据库，用sql对数据进行增删改查 通过JDBC开发的数据库应用可跨平台 数据库驱动程序：JDBC与数据库之间的转换层，负责将JDBC调用映射成特定的数据库调用 二、JDBC编程1.常用类和接口DriverManager：用于管理JDBC驱动的服务类，用于获取Connection对象 Connection：数据库连接对象，每个Connection代表一个连接会话。它是一个接口，可通过Statement，Preparedstatement来实例化，获取其对象 Statement：用于执行sql的工具接口 PreparedStatement：预编译的Statement对象，是Statement子接口，可以预编译sql语句，允许sql语句含参，方便后来修改也可避免每次都编译sql语句，性能好。 Statement和PreparedStatement都有execute()，executeUpdate()，executeQuery()，返回查询的结果集，executeUpdate()可执行DML语句，返回受影响的行数，executeQuery()可以执行DDL语句，返回结果集对象，所以一般不用execute()方法，返回的是ResultSet结果集。 ResultSet：结果集对象，包含很多查询结果的方法，可以根据列名或列索引来获取结果，也有很多种方法来移动记录指针，最常用的是next()方法。 2.步骤(以MySQL为例)123Connection conn = null;PreparedStatement pstmt = null;ResultSet rs = null; (1).加载数据库驱动1Class.forName(\"com.mysql.cj.jdbc.Driver\"); (2).获取数据库连接1conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/test?useSSL=false&amp;serverTimezone=UTC\",\"root\", \"password\"); (3).通过Connection创建PreparedStatement对象1pstmt = conn.prepareStatement(sql); (4).执行sql语句12rs = pstmt.executeQuery();result = pstmt.executeUpdate; 三、模板这些语句都可以被封装成单独的函数进行使用，更加方便，不用每次再进行定义。 下面是DAO模式分层后，最底层与数据库交互的BaseDao类，方便再使用时拷贝， 连接数据库还需要一个.property文件，里面记录了驱动，数据库位置，用户和密码，每次使用只需要改这里就可以 1234driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/test?useSSL=false&amp;serverTimezone=UTCuser=rootpassword=123456 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133/** * 数据库连接与关闭工具类。 */public class BaseDao &#123; public static String DRIVER; // 数据库驱动 public static String URL ; // url public static String DBNAME; // 数据库用户名 public static String DBPASS; // 数据库密码 Connection conn = null;// 数据连接对象 static&#123;//静态代码块,在类加载的时候执行 init(); &#125; /** * 初始化连接参数,从配置文件里获得 */ public static void init()&#123; Properties params=new Properties(); String configFile = \"database.properties\";//配置文件路径 //加载配置文件到输入流中 InputStream is=BaseDao.class.getClassLoader().getResourceAsStream(configFile); try &#123; //从输入流中读取属性列表 params.load(is); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //根据指定的获取对应的值 DRIVER=params.getProperty(\"driver\"); URL=params.getProperty(\"url\"); DBNAME=params.getProperty(\"user\"); DBPASS=params.getProperty(\"password\"); &#125; /** * 得到数据库连接 * * @throws ClassNotFoundException * @throws SQLException * @return 数据库连接 */ public Connection getConnection() throws ClassNotFoundException, SQLException &#123; Connection conn = null; try &#123; Class.forName(DRIVER); // 注册驱动 conn = DriverManager.getConnection(URL, DBNAME, DBPASS); // 获得数据库连接 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return conn; // 返回连接 &#125; /** * 释放资源 * * @param conn * 数据库连接 * @param pstmt * PreparedStatement对象 * @param rs * 结果集 */ public void closeAll(Connection conn, PreparedStatement pstmt, ResultSet rs) &#123; /* 如果rs不空，关闭rs */ if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /* 如果pstmt不空，关闭pstmt */ if (pstmt != null) &#123; try &#123; pstmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /* 如果conn不空，关闭conn */ if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 执行SQL语句，可以进行增、删、改的操作，不能执行查询 * * @param sql * 预编译的 SQL 语句 * @param param * 预编译的 SQL 语句中的‘？’参数的字符串数组 * @return 影响的条数 */ public int executeSQL(String preparedSql, Object[] param) &#123; Connection conn = null; PreparedStatement pstmt = null; int num = 0; /* 处理SQL,执行SQL */ try &#123; conn = getConnection(); // 得到数据库连接 pstmt = conn.prepareStatement(preparedSql); // 得到PreparedStatement对象 if (param != null) &#123; for (int i = 0; i &lt; param.length; i++) &#123; pstmt.setObject(i + 1, param[i]); // 为预编译sql设置参数 &#125; &#125; num = pstmt.executeUpdate(); // 执行SQL语句 &#125; catch (ClassNotFoundException e) &#123; //e.printStackTrace(); // 处理ClassNotFoundException异常 &#125; catch (SQLException e) &#123; //e.printStackTrace(); // 处理SQLException异常 &#125; finally &#123; this.closeAll(conn, pstmt, null); &#125; return num; &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://linxd1999.github.io/tags/Java/"}]},{"title":"进程管理","slug":"Process Management(1)-dispatch","date":"2019-06-16T15:51:31.245Z","updated":"2019-06-16T15:51:31.245Z","comments":true,"path":"2019/06/16/Process Management(1)-dispatch/","link":"","permalink":"https://linxd1999.github.io/2019/06/16/Process Management(1)-dispatch/","excerpt":"一、进程和线程1、进程 进程(Process)：一个具有独立功能的程序关于一个数据集合上的一次动态执行过程 进程的组成：代码段、程序处理的数据、程序计数器(指示下一条将运行的指令)、系统资源 进程的特点： 1、动态性：进程是进程实体的一次执行过程 2、并发性：多个进程同时存在于内存中并能在一段时间内同时运行 3、独立性：在传统OS中，进程是一个能独立运行、分配资源、调度的基本调度 4、异步性：进程按各自独立、不可预知的速度向前推进 进程控制块(PCB)：每个进程用来保存与该进程有关的各种状态信息，是进程存在的唯一标识 进程的状态：创建、运行、等待(阻塞)、就绪、结束 1、进程只能自己阻塞自己，只有自己知道自己什么时候需要等待事件发生 2、阻塞态不能直接转换成运行态 3、挂起态：进程没有占有内存空间，处于挂起态的进程映像在磁盘上 上下文切换：OS内核将旧进程的关联状态保存在其PCB中，然后装入经调度之后准备执行的新进程的已保存的关联状态","text":"一、进程和线程1、进程 进程(Process)：一个具有独立功能的程序关于一个数据集合上的一次动态执行过程 进程的组成：代码段、程序处理的数据、程序计数器(指示下一条将运行的指令)、系统资源 进程的特点： 1、动态性：进程是进程实体的一次执行过程 2、并发性：多个进程同时存在于内存中并能在一段时间内同时运行 3、独立性：在传统OS中，进程是一个能独立运行、分配资源、调度的基本调度 4、异步性：进程按各自独立、不可预知的速度向前推进 进程控制块(PCB)：每个进程用来保存与该进程有关的各种状态信息，是进程存在的唯一标识 进程的状态：创建、运行、等待(阻塞)、就绪、结束 1、进程只能自己阻塞自己，只有自己知道自己什么时候需要等待事件发生 2、阻塞态不能直接转换成运行态 3、挂起态：进程没有占有内存空间，处于挂起态的进程映像在磁盘上 上下文切换：OS内核将旧进程的关联状态保存在其PCB中，然后装入经调度之后准备执行的新进程的已保存的关联状态 2、线程 线程(Thread)：OS中能进行调度的最小单位，包含在进程之中，是进程中的实际运作单位 线程的组成：线程id、程序计数器、各种寄存器、栈 线程的特点：和属于同一进程的其他线程共享代码段、数据段和其他OS资源 例如：浏览器这个进程可分为很多页面线程，不同页面可以做不同的事情 线程的优点： 1、响应度高：部分线程阻塞或操作时间冗长，该程序仍然能执行下去，增加对用户的响应程度 2、资源共享：允许一个进程在同一个地址空间有多个活动的线程 3、经济：进程创建所需的内存和资源分配昂贵，而线程则相对经济 4、适合多处理器结构：单线程进程只能运行在一个CPU上，在多CPU上使用多线程加强了OS的并发能力 进程、线程的区别： 1、调度性：在传统OS中，拥有资源和独立调度分配的基本单位都是进程；在引入线程的OS中，线程是调度分配的基本单位，而进程是资源分配的基本单位 2、并发性：在引入线程的OS中，进程之间可以并发执行，同一进程的线程之间也可以并发执行，从而使OS有更好的并发性 3、拥有资源：进程拥有自己的资源，线程一般不拥有资源，但可以访问其所在进程的资源 4、系统开销：创建、撤销进程涉及系统资源的分配与回收，需要比线程的创建和撤销大得多的系统开销，进程切换的开销也远大于线程 二、进程调度(dispatch)1、调度层次 长期调度/高级调度/作业调度：把进程从磁盘中首次调入内存，只有进程离开系统时，才需要长期调度程序的调度。必定发生，但频率比较低。 中期调度/中级调度/内存调度：在分时操作系统中，将进程从内存调入磁盘，从而减少内存中的进程数据。之后需要时再重新调入内存，并从中断处继续执行。可能发生，频率中等。 短期调度/低级调度/进程调度：从就绪态中选择进程分配CPU，必定发生，且频率很高。 2、调度准则 CPU使用率：需要让CPU尽可能忙 吞吐量：单位时间内完成的进程数量 周转时间：从进程提交到进程完成所用的时间 等待时间：进程在就绪队列中等待所花费的时间之和 响应时间：从提交请求到产生第一响应的时间 3、调度算法1、先来先服务算法(FCFS)例：银行排队、打印机 方式：非抢占 调度时机：一个进程结束 特点：利于长进程，不利于短进程；利于CPU繁忙的作业，不利于IO繁忙的作业；不适用于分时，实时系统 2、 短作业优先调度算法(SJF)思想：优先对短作业或短进程进行处理的算法，如果两个进程长度相同，可用FCFS处理(插队+动态改变) 方式：非抢占 / 抢占(最短剩余时间优先调度) 调度时机：程序结束时 / 阻塞I/O时 特点：利于短进程，不利于长进程(饥饿)；不能保证紧迫作业及试运行(程序员可能提供虚假时间)；平均等待时间，平均周转时间最少；吞吐量很大(单位时间内运行的进程数多) 3、高优先级调度算法思想：优先对高优先级的进程进行处理 方式：抢占 / 非抢占 调度时机：程序结束时 / I/O阻塞时 / 更高优先级进程进入队列时 特点：满足紧迫作业需求；适用于实时系统；优先级分为动态优先级和静态优先级 4、轮转法调度算法(RR)思想：分时间片使各进程轮流获取CPU(10ms-100ms) 方式：抢占 调度时机：时间片用完 / 程序结束 特点：时间片大小讲究，太大退化为FCFS，太小上下文切换次数很多，开销大；适用于分时系统 5、高响应比优先算法响应比Rp = (等待时间+服务时间) / 服务时间 思想：优先选择响应比高的作业(从外存放到内存的过程中，包含的一个或多个进程) 方式：无(主要用于作业调度) 调度时机：无 特点：FCFS与SJF的平衡；克服饥饿，既能兼顾长作业，又能让短作业先运行 6、多级反馈队列算法思想：FCFS(每个窗口都排队)+优先级(每个窗口都有优先级)+时间片轮转(时间片成倍增加，最后一个窗口循环轮转)，多级反馈队列不必事先知道各种进程所需的执行时间，还可以满足各种类型的进程需要。 方式：综合 调度时机：综合 特点：短作业优先带来的等待时间降低，周转时间降低；长作业能得到处理 三、同步与互斥1、相关概念 临界资源：一次仅允许一个进程使用的资源(打印机，网卡，键盘，共享变量) 临界区：每个进程中访问临界资源的那段代码 信号量(semaphore)：用来保证两个或多个临界区代码不被并发调用 互斥：两个或以上进程，不同时进入关于同一组共享变量的临界区，否则可能发生时间相关的错误 同步：在多道程序环境下，进程并发执行，进程因相互协作完成某个操作的次序关系 PV操作：控制信号量的一组原子操作，P是等待(减法，检测，阻塞)，V是释放(加法，检测，唤醒) 2、实现互斥的方法1、硬件实现法 中断屏蔽法：进程切换大多源于中断，若没有切换，也就不需要互斥，所以屏蔽中断即可实现互斥 原子硬件指令法：TestAndSet、Swap 2、软件实现法 单标志法 思想：一个进程的进入临界区权限只能被另外一个进程赋予，但两个进程必须交替进入临界区，如果某个进程不进入临界区，那么另外一个进程也无法进入临界区，造成资源浪费 双标志先检查法 思想：一个进程进入临界区之前先查看临界区资源是否被访问，若没有被访问，则把自身标志位设置为true，若被访问则等待 双标志后检查法 思想：防止先检查法的同时进入临界区问题，先上锁，后检查(会因为两个进程因为争夺临界区过于强势导致没有一个进程能获取临界区资源，导致饥饿) Peterson算法 思想：”孔融让梨”的思想，虽然表示自己也想获取临界区资源，但主动询问对方是否想访问，若对方想访问临界区资源且自己谦让了，对方进入临界区 3、信号量的使用伪代码： 若s.value&gt;0，则临界区资源可以被获取 若s.value&lt;=0，则临界区满，需要排队获取 实现互斥：s.value=1 实现同步：s.value=0 1、 生产者与消费者问题特征：容器内的物品数量&lt;=容量 分析：生产者关注剩余空间(emtpy)；消费者关注已占有空间(full)；互斥信号量mutex(用于影响容器大小的语句两端) 有几个容器就需要几个互斥信号量mutex 2、读者与写者问题特征：资源是否被占用；写者可写文件，但读者只能访问 例：有读写两组进程共享一个文件，多个读者可同时访问文件，多个写者不能同时访问文件，读者和写者不能同时访问文件 四、死锁1、相关概念 死锁：两个或两个以上的进程(或线程)在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都无法推进下去 活锁：两个线程，都很谦让，最后导致两个线程都无法获取资源 饥饿：某个进程因为其他进程轮流占用CPU导致它很久无法占用CPU的情况 死锁产生原因： 应用程序层面：信号量使用不当 OS内核程序层面：不可抢占软硬件资源(多进程对有限不可抢占资源的竞争，进程申请资源的推进顺序不合理 死锁产生的必要条件 互斥条件：必须有临界资源 占有并等待：一个进程必须占有一个资源，并等待另一资源，而该资源为其他进程所占有 非抢占：资源不能被抢占 循环等待：一组等待进程，每个进程所请求的资源都被另一个进程所占有 处理死锁的策略：预防死锁，避免死锁，检测与解除死锁 预防死锁：通过扼杀其产生的必要条件 互斥：几乎行不通 不可抢占：强行抢占某资源 占有并等待：一次性把资源申请完 循环等待：顺序资源分配法 死锁避免：银行家算法(规划合理的资源申请顺序，安全序列)","categories":[],"tags":[{"name":"OS","slug":"OS","permalink":"https://linxd1999.github.io/tags/OS/"}]},{"title":"Common Words and Phrases","slug":"常用单词和词组整理","date":"2019-06-13T07:44:28.521Z","updated":"2019-06-13T07:44:28.521Z","comments":true,"path":"2019/06/13/常用单词和词组整理/","link":"","permalink":"https://linxd1999.github.io/2019/06/13/常用单词和词组整理/","excerpt":"一、常用单词 中 英 统治 govern reign 推动、促进 promote boost facilitate 蓬勃发展 boom mushroom surge flourish thrive 兴荣的 prosperous booming thriving flourishing 稳定的 stable steady 大量、许多 multiple numerous 交易 deal(n.) trade(v.) 发行 publish(书、报纸) issue(钱/股票) 政府(管理) government administration 超过 exceed surpass 领域 field domain territory 激增 balloon soar multiply 骤降 plunge 显著的 notable noticeable remarkable prominent conspicuous 危险 risk danger jeopardy 处理、解决 solve settle tackle 加速 accelerate hasten 获得、收获 gain reap 破坏 destory devastate disrupt 观众 audience spectator 刺激、鼓舞 stimulate(stimulus) spur motivate 商品 goods commodity merchandise 成功的 successful triumphant 重要的 critical significant essential vital crucial 灿烂的 brilliant splendid glorious marvellous fascinating 同时 meanwhile simultaneously 著名的 famous celebrated noted renowned 比赛 competition race(运动) event(运动) 因此 therefore hence 渴望 long crave yearn 目的 purpose aim sake 实施、执行 implement execute 撤退 withdraw retreat 悲惨的 tragic miserable bleak(惨淡的) 缺点 defect flaw weakness shortcoming disadvantage 消失 disappear vanish 保证 promise guarantee pledge 预示 indicate herald anticipate 公平 justice fairness 面对 face confront 忽视、忽略 neglect overlook ignore 预测 predict forecast 分配 allocate allot assign 诱惑 tempt lure 巨大的 huge enormous tremendous massive 足够的 enough adequate sufficient 相同的 same uniform identical 驱使，引发 trigger provoke propel 削减 cut down cripple 剥夺 deprive strip 授权 authorize empower 让步、妥协 compromise concession","text":"一、常用单词 中 英 统治 govern reign 推动、促进 promote boost facilitate 蓬勃发展 boom mushroom surge flourish thrive 兴荣的 prosperous booming thriving flourishing 稳定的 stable steady 大量、许多 multiple numerous 交易 deal(n.) trade(v.) 发行 publish(书、报纸) issue(钱/股票) 政府(管理) government administration 超过 exceed surpass 领域 field domain territory 激增 balloon soar multiply 骤降 plunge 显著的 notable noticeable remarkable prominent conspicuous 危险 risk danger jeopardy 处理、解决 solve settle tackle 加速 accelerate hasten 获得、收获 gain reap 破坏 destory devastate disrupt 观众 audience spectator 刺激、鼓舞 stimulate(stimulus) spur motivate 商品 goods commodity merchandise 成功的 successful triumphant 重要的 critical significant essential vital crucial 灿烂的 brilliant splendid glorious marvellous fascinating 同时 meanwhile simultaneously 著名的 famous celebrated noted renowned 比赛 competition race(运动) event(运动) 因此 therefore hence 渴望 long crave yearn 目的 purpose aim sake 实施、执行 implement execute 撤退 withdraw retreat 悲惨的 tragic miserable bleak(惨淡的) 缺点 defect flaw weakness shortcoming disadvantage 消失 disappear vanish 保证 promise guarantee pledge 预示 indicate herald anticipate 公平 justice fairness 面对 face confront 忽视、忽略 neglect overlook ignore 预测 predict forecast 分配 allocate allot assign 诱惑 tempt lure 巨大的 huge enormous tremendous massive 足够的 enough adequate sufficient 相同的 same uniform identical 驱使，引发 trigger provoke propel 削减 cut down cripple 剥夺 deprive strip 授权 authorize empower 让步、妥协 compromise concession 规模：scale 大规模的：large-scale / mass 城市化：urbanization 边界/界限：boundary 边境/国界：border 大都市：metropolis 禁止：inhibit 栖息、居住于：inhabit 展示、展览：exhibit 把…归咎于：attribute 贡献：contribute 阻碍：hinder 可行的：feasible 合理的：rational 不合理的：irrational 无理由的：groundless 学科类 数学 mathematics 科学 science 哲学 philosophy 物理 physics 心理学 psychology 化学 chemistry 生物 biology 生物化学 biochemisty 政治 politics 文学 literature 体育 gymnastics 地理 geography 农业类 农业 agriculture 机械 machinery 农作物 crop 小麦 wheat 豆类 beans 水稻 rice 可开垦的 arable 耕作 cultivation 肥料 fertilizer 产量 yield 生产力(率) productivity 有机的 organic 无机的 inorganic 经济类 通货膨胀 inflation 波动 fluctuate 大幅削减 slash 基金 fund/capital 环境类 温室的 greenhouse 排放 emission 易受伤的 vulnerable 化石燃料 fossil fuel 负担 burden 生活类 体温计 thermometer 旗舰店 flagship store 所有物，财产 property 机构 agency 生的 raw 仓库 repository journal 旅游 journey 态度类 有野心的 ambitious 不情愿的 reluctant 模糊的 ambiguous 开明的 liberal 中立的 neutral 失望的 disappointed 二、常用词组占地…面积：with a area of / cover a area of 平方米(千米)：square meter(kilometer) 表范围：range in 长度/宽度/大小 from … to … 海拔：1000 meters above the sealevel / at an altitude of 1000 meters 在…西边多远：100 kilometers west of … 来源于… ：originate from… 追溯到：trace back to / date back to 另一方面：on the other hand / on the flip side","categories":[],"tags":[{"name":"English","slug":"English","permalink":"https://linxd1999.github.io/tags/English/"}]},{"title":"内存分页和分段","slug":"内存管理","date":"2019-06-04T16:10:09.082Z","updated":"2019-06-04T16:10:09.082Z","comments":true,"path":"2019/06/05/内存管理/","link":"","permalink":"https://linxd1999.github.io/2019/06/05/内存管理/","excerpt":"","text":"","categories":[],"tags":[{"name":"OS","slug":"OS","permalink":"https://linxd1999.github.io/tags/OS/"}]},{"title":"进程管理(三)：死锁","slug":"Process Management(3)-deadlock","date":"2019-05-28T14:01:36.005Z","updated":"2019-05-28T14:01:36.005Z","comments":true,"path":"2019/05/28/Process Management(3)-deadlock/","link":"","permalink":"https://linxd1999.github.io/2019/05/28/Process Management(3)-deadlock/","excerpt":"","text":"","categories":[],"tags":[{"name":"OS","slug":"OS","permalink":"https://linxd1999.github.io/tags/OS/"}]},{"title":"进程管理(二)：同步与互斥","slug":"Process Management(2)-mutex","date":"2019-05-28T14:00:55.179Z","updated":"2019-05-28T14:00:55.179Z","comments":true,"path":"2019/05/28/Process Management(2)-mutex/","link":"","permalink":"https://linxd1999.github.io/2019/05/28/Process Management(2)-mutex/","excerpt":"","text":"","categories":[],"tags":[{"name":"OS","slug":"OS","permalink":"https://linxd1999.github.io/tags/OS/"}]},{"title":"Hexo博客框架+GitHub部署","slug":"Hexo博客框架+GitHub部署","date":"2019-05-28T11:27:58.616Z","updated":"2019-05-28T11:27:58.616Z","comments":true,"path":"2019/05/28/Hexo博客框架+GitHub部署/","link":"","permalink":"https://linxd1999.github.io/2019/05/28/Hexo博客框架+GitHub部署/","excerpt":"特别感谢up主CodeSheep的视频教程, 原视频请点击Step1： 安装Node.jsNode.js官网下载: https://nodejs.org/en/download/ Step2： 安装GitGit是一个开源的分布式版本控制系统，是为了帮助管理Linux内核开发而开发的版本控制软件。 Git官网下载: https://www.git-scm.com/download/ 安装完之后鼠标右击会出现Git Bash Here， 这就相当于Linux终端，我们等会对博客的操作也都是在这里完成。","text":"特别感谢up主CodeSheep的视频教程, 原视频请点击Step1： 安装Node.jsNode.js官网下载: https://nodejs.org/en/download/ Step2： 安装GitGit是一个开源的分布式版本控制系统，是为了帮助管理Linux内核开发而开发的版本控制软件。 Git官网下载: https://www.git-scm.com/download/ 安装完之后鼠标右击会出现Git Bash Here， 这就相当于Linux终端，我们等会对博客的操作也都是在这里完成。 一些常用的Linux命令行操作： cd ：进入目录 cd ..：返回上一级目录 cd../..：返回上两级目录 pwd：显示当前路径 ls -l：显示当前路径下文件的详细信息 Step3： 安装HexoHexo是一个快速，简洁，高效的博客框架。Hexo使用Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用华丽的主题生成静态网页。 随便在一个盘下新建文件夹，用来操作博客用，后面我都用Blog来表示这个文件夹。 进入Blog文件夹，右键Git Bash Here，首先测试node和npm的版本。 输入命令： 然后安装一个cnpm提高下载速度： npm install -g cnpm –registry=https://registry.npm.taobao.org 测试cnpm： 然后安装Hexo： cnpm install -g hexo-cli 验证是否安装成功 hexo -v 安装成功！ 然后在根目录下执行： hexo init 这是建立整个项目，若Blog文件夹下出现了很多文件则说明成功了。 Step4：运行测试 hexo clean 清理缓存文件 hexo g 生成文件 hexo s 运行本地服务器 hexo d 部署到远端服务器 先在根目录下运行hexo s 然后打开浏览器，输入localhost:4000，出现以下界面 至此，本地环境已经搭建好了。 Step5：部署到Github上登录Github，创建一个新的仓库new repository，仓库名称为你的Github ID.github.io（必须是这这样写） 然后在根目录下安装一个Git部署插件 cnpm install –save hexo-deployer-git 在根目录下的_config.yml文件下修改一些配置 repo把打开仓库看到的那个git结尾的复制进来就好。 最后部署到远端：hexo d 之后会出现一些验证，照着提示做就可以了。 推送到远端成功后，在浏览器输入你的Github ID.github.io就可以访问博客了。","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://linxd1999.github.io/tags/Hexo/"}]},{"title":"记录一些好用的网站","slug":"记录一些好用的网站","date":"2019-05-17T14:25:08.735Z","updated":"2019-05-17T14:25:08.735Z","comments":true,"path":"2019/05/17/记录一些好用的网站/","link":"","permalink":"https://linxd1999.github.io/2019/05/17/记录一些好用的网站/","excerpt":"","text":"1、高清电脑壁纸(wallhaven)：https://alpha.wallhaven.cc/ 2、在线作图(ProcessOn)：https://www.processon.com/ 3、GitHub(面向开源及私有软件项目的托管平台)：https://github.com/ 4、Java学习：http://how2j.cn/ 5、Linux命令行学习：http://linuxcommand.org/","categories":[],"tags":[{"name":"推荐","slug":"推荐","permalink":"https://linxd1999.github.io/tags/推荐/"}]}]}
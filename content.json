{"meta":{"title":"L","subtitle":null,"description":"站在巨人的肩上","author":"linxd","url":"https://linxd1999.github.io","root":"/"},"pages":[{"title":"标签","date":"2019-05-28T09:46:12.000Z","updated":"2019-12-27T06:33:34.031Z","comments":true,"path":"tags/index.html","permalink":"https://linxd1999.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Git & Github","slug":"Git","date":"2019-12-27T08:02:20.815Z","updated":"2019-12-27T08:02:20.815Z","comments":true,"path":"2019/12/27/Git/","link":"","permalink":"https://linxd1999.github.io/2019/12/27/Git/","excerpt":"","text":"一.Git基本概念1.版本控制系统 Git是开源的分布式版本控制系统，可以处理项目的版本控制 功能 协同修改：多人并行修改服务器端的同一个文件 权限控制：开发团队内外的人员拥有不同的权限 历史记录：查看修改人，修改时间，修改内容等 数据备份：保存当前状态，还保存每一个提交过的历史状态 分支操作：多条生产线同时推进任务 优势 在本地完成操作，不需要联网 尽可能添加数据而不是删改数据 数据完整性的保证(哈希算法) 2.Git结构 工作区：写代码的区域 暂存区：写完但还没有提交的命令(临时存储) 本地库：储存历史的版本 3.本地库和远程库 远程库位于代码托管中心 团队内部协作：远程库的控制者把本地库推送到远程库，然后团队开发人员可以clone该远程库到自己的本地库，然后修改后再推送到远程库 跨团队协作：团队外的人可以fork别人的远程库，然后在本地修改之后，再推送到远程库中，通过提交pull request请求，经审核通过后合并到别人的远程库中 二.Git命令行操作1.本地库初始化 命令：git init 在Git终端中，进入目录使用该命令，即可初始化一个本地库 .git目录是隐藏目录，存放的是本地库相关的子目录和文件，不能删除和胡乱修改 2.设置签名 作用：区分不同开发人员的身份 这里设置的签名和登录远程库的账号密码没有关系 项目级别/仓库级别：仅在当前本地仓库范围内有效 git config user.name abc git config user.email abc@qq.com 信息保存位置：./.git/config(cat .git/config) 系统用户级别：登录当前操作系统的用户范围 git config –global user.name abc git config –global user.email abc@qq.com 信息保存位置：~/.gitconfig(cat ~/.gitconfig) 两者必须有一个，但项目级别优先级更高 3.基本操作 状态查看：git status(查看工作区，暂存区状态) 添加：git add [file name] (将工作区的”新建/修改”添加到暂存区) 提交：git commit -m “commit message” [file name] (将暂存区中的内容提交到本地库) 查看历史记录： git log：显示具体信息(多屏显示，space向下翻页，b向上翻页，q退出) git log –pretty=oneline：单行显示 git log –oneline：简化单行显示 git reflog：HEAD@{移动到当前版本需要多少步} 版本前进后退 索引值：git reset –hard [局部索引值] ^符号(只能后退)：git reset –hard HEAD^ (一个^表示后退一步，n个表示后退n行) ~符号(只能后退)：git reset –hard HEAD~n(表示后退n步) reset参数： soft：只更改head指针的位置，暂存区和工作区不变，工作区内容不会丢失 mixed：默认参数，让暂存区和本地库一致，但工作区内容不会丢失 hard：head指针，暂存区，工作区三者一致，指针指向版本后做的更新全部丢失 找回删除文件：只要commit之后就会有记录，用reflog能看到所有修改的记录 git reset –hard [指针位置] 可以找回一切提交过的记录版本 删除操作还没提交到本地库，指针位置用HEAD 比较文件差异：如果git status中working tree clean，则没有输出 git diff [文件名]：工作区的文件与暂存区的文件相比较 git diff [本地库中历史版本] [文件名] ：工作区的文件和本地库历史记录比较 不指定文件名可以比较所有文件：git diff HEAD 4.分支管理 分支：多条线并行推进任务，以免影响主线开发 优点：提升开发效率；如果一个分支开发失败，不会对主线造成任何影响，删除重新开始即可 创建分支：git branch [分支名] 查看分支：git branch -v 切换分支：git checkout [分支名] 合并分支： 切换到需要被修改的分支git checkout [被合并的分支] 合并git merge [有新内容的分支名] 解决冲突： 冲突：不同分支在同一个位置进行修改 1.编辑文件，删除特殊符号 2.保存文件 3.git add [文件名] 4.git commit -m “日志信息” (不能带文件名) 合并操作需要在提交到本地库(commit)之后才能合并 三.Git基本原理1.哈希算法 哈希函数(散列函数)：把任意长度的输入通过散列算法转换成相同长度的输出，散列值的空间远小于原输入的空间 特点 输出长度固定 输入数据确定，则输出数据保持不变 输入数据变化，则输出数据会有很大变化 不同的输入可能有相同输出，所以哈希算法不可逆 Git底层用的是SHA-1算法来保证数据的完整性 2.Git保存版本的机制 Git把数据看作小型文件系统的一组快照，每次提交更新时Git会对当前全部文件制作一个快照并保存快照的索引。 如果文件没有修改，则不会重新存储该文件，而是保留一个指向之前储存的文件。 快照的理解：当你删除一个文件后，文件原来所占的磁盘空间并不是被清空，而是被文件系统标记为“已废弃，可修改”的状态，快照的作用就相当于将旧文件所占的空间保留下来，并且保存一个引用，而新文件中会继续使用与旧文件内容相同部分的磁盘空间，不同部分则写入新的磁盘空间 Git的数据文件管理和分支管理都用的是指针操作，效率高 四.Github1.创建远程库地址别名 查看当前所有远程地址别名：git remote -v 创建远程地址别名：git remote add [别名] [远程地址] 2.推送 git push [别名] [分支名] 3.克隆 git clone [远程地址] 效果 完整的把远程库下载到本地 创建远程地址别名 初始化本地库 4.团队成员邀请 Settings-Collaborators-Add collaborator(输入账号)-Copy invite link发送给对方-对方打开链接接收邀请-加入团队成功 5.拉取 pull=fetch+merge git fetch [远程库地址别名] [远程分支名] git merge [远程库地址别名/远程分支名] git pull [远程库地址别名] [远程分支名] 如果你添加.gitignore的时候，git里面已经上传了很多不需要的文件，则使用下面两个命令干掉他们 如果是文件夹：git rm -r –cached 文件夹名 如果是文件：git rm –cached 文件名","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://linxd1999.github.io/tags/Git/"}]},{"title":"JDK8的新特性","slug":"JDK8新特性","date":"2019-12-27T07:59:19.186Z","updated":"2019-12-27T07:59:19.186Z","comments":true,"path":"2019/12/27/JDK8新特性/","link":"","permalink":"https://linxd1999.github.io/2019/12/27/JDK8新特性/","excerpt":"Lambda表达式1.定义 Lambda 是一个匿名函数，我们可以把 Lambda 表达式理解为是一段可以传递的代码（将代码像数据一样进行传递。使用它可以写出更简洁、更 灵活的代码。作为一种更紧凑的代码风格 2.格式 -&gt;：lambda操作符或箭头操作符 左侧：lambda形参列表(接口中抽象方法的形参列表) 右侧：lambda体(重写抽象方法的方法体) 本质：作为接口的实例(java万物皆对象)，lambda表达式也是一个对象","text":"Lambda表达式1.定义 Lambda 是一个匿名函数，我们可以把 Lambda 表达式理解为是一段可以传递的代码（将代码像数据一样进行传递。使用它可以写出更简洁、更 灵活的代码。作为一种更紧凑的代码风格 2.格式 -&gt;：lambda操作符或箭头操作符 左侧：lambda形参列表(接口中抽象方法的形参列表) 右侧：lambda体(重写抽象方法的方法体) 本质：作为接口的实例(java万物皆对象)，lambda表达式也是一个对象 3.语法3.1 无参，无返回值1Runnable r = () -&gt; &#123;System.out.println(\"helloworld\")&#125;; 3.2 需要一个参数，但没有返回值1Consumer&lt;String&gt; c = (String str) -&gt; &#123;System.out.println(\"helloworld\")&#125;; 3.3 类型推断 通过泛型来进行类型推断，省略形参的类型 1Consumer&lt;String&gt; c = (str) -&gt; &#123;System.out.println(\"helloworld\")&#125;; 3.4 单形参 括号可省略 1Consumer&lt;String&gt; c = str -&gt; &#123;System.out.println(&quot;helloworld&quot;)&#125;; 3.5 多形参，多执行语句1234Comparator&lt;Integer&gt; c = (o1, o2) -&gt; &#123; System.out.println(\"helloworld\") Integer.compare(o1,o2);&#125;; 3.6 单执行语句 大括号和return都可以省略，且必须同时省略或不省略 1Comparator&lt;Integer&gt; c = (o1,o2) -&gt; Integer.compare(o1,o2);","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://linxd1999.github.io/tags/Java/"}]},{"title":"面向对象(类、继承、多态)","slug":"面向对象(类、继承、多态)","date":"2019-12-27T06:33:34.031Z","updated":"2019-12-27T06:33:34.031Z","comments":true,"path":"2019/12/27/面向对象(类、继承、多态)/","link":"","permalink":"https://linxd1999.github.io/2019/12/27/面向对象(类、继承、多态)/","excerpt":"","text":"一. 类、对象、引用、指针1.引用变量及内存分析众所周知Java没有指针，但实际上Java的引用就相当于指针，只不过把这个指针封装起来，避免其繁琐的操作。 例如Person p = new Person()，这行代码创建了一个实例，实际上，p作为一个引用变量(只存放对象地址)存放在调用这行代码的方法栈中，而Person作为一个对象被存放在堆内存中，然后引用变量p指向堆里的Person。Java程序不允许直接访问堆内对象，只能通过引用变量来访问。若堆内的对象没有任何引用变量指向它，则这个对象会被GC回收，反之，若想让GC回收某对象，只需要切断所有引用变量跟这个对象的联系即可。 2.this关键字this关键字总是指向调用该方法的对象，其最大的作用就是让类里的一个方法调用类里的另外一个方法或者实例变量。 Java允许对象的一个成员直接调用另一个成员可以忽略this前缀。 3.static关键字static关键字的真正作用：区分成员变量，方法，内部类是属于类本身还是属于类的实例 有static修饰的成员属于类本身，没有static修饰的成员属于类的实例。 因为static成员属于类本身，所以调用static成员是什么实例并不明确，所以不能在static方法内使用this关键字、super关键字。 方法以this作为返回值：可以在一行代码中多次连续调用该方法。 4.参数传递机制1234567891011121314151617 public class Swap &#123; int a,b; public Swap(int a,int b) &#123; this.a = a; this.b = b; &#125; public static void swap(Swap temp) &#123; int tmp = temp.a; temp.a = temp.b; temp.b = tmp; &#125; public static void main(String args[]) &#123; Swap s = new Swap(3,4); swap(s); System.out.println(s.a+\" \"+s.b); &#125;&#125; 首先在main函数内，main函数的栈内存放了引用变量s，指向堆内存的对象Swap；swap函数传入一个形参temp也指向堆内存里的Swap对象。所以两个引用变量都指向堆内存中的对象，只要操作一个引用变量，堆内存中对象的数据就会改变，所以数据交换可以成功。 5.成员变量、局部变量成员变量：不被static修饰的实例变量，被static修饰的类变量 局部变量：形参，方法中的变量，代码块中的变量 6.访问控制符private：当前类访问权限 default：包访问权限，可被相同包下的其他类访问 protected：子类访问权限，可被不同包中的子类访问 public：公共访问权限，可被所有类访问","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://linxd1999.github.io/tags/Java/"}]},{"title":"记录一些好用的网站","slug":"记录一些好用的网站","date":"2019-12-27T06:33:34.015Z","updated":"2019-12-27T06:33:34.015Z","comments":true,"path":"2019/12/27/记录一些好用的网站/","link":"","permalink":"https://linxd1999.github.io/2019/12/27/记录一些好用的网站/","excerpt":"","text":"1、高清电脑壁纸(wallhaven)：https://alpha.wallhaven.cc/ 2、在线作图(ProcessOn)：https://www.processon.com/ 3、GitHub(面向开源及私有软件项目的托管平台)：https://github.com/ 4、Java学习：http://how2j.cn/ 5、Linux命令行学习：http://linuxcommand.org/","categories":[],"tags":[{"name":"recommendation","slug":"recommendation","permalink":"https://linxd1999.github.io/tags/recommendation/"}]},{"title":"红黑树","slug":"红黑树","date":"2019-12-27T06:33:33.984Z","updated":"2019-12-27T06:33:33.984Z","comments":true,"path":"2019/12/27/红黑树/","link":"","permalink":"https://linxd1999.github.io/2019/12/27/红黑树/","excerpt":"","text":"一.红黑树(Red-Black Tree) 红黑树是一种自平衡的二叉搜索树，也叫做平衡二叉B树(symmetric Binary B-tree) 性质： 节点是RED或者BLACK 根节点是BLACK 叶子节点(外部节点，空节点)都是BLACK RED节点的子节点都是BLACK，RED节点的父节点都是BLACK，从根节点到叶子节点的所有路径不能有两个连续的RED节点 从任一节点到叶子节点的所有路径都包含相同数目的BLACK节点(所有路径包括到外部节点和空节点的路径) 红黑树和2-3-4树具有等价性，BLACK节点和它的RED子节点融合在一起，形成一个B树节点 红黑树的BLACK节点个数与四阶B树的节点总个数相等 每个B树节点都只有一个黑色节点，且都是与上层连接的节点","categories":[],"tags":[{"name":"Tree","slug":"Tree","permalink":"https://linxd1999.github.io/tags/Tree/"},{"name":"DataStruture","slug":"DataStruture","permalink":"https://linxd1999.github.io/tags/DataStruture/"}]},{"title":"盒模型","slug":"盒子模型","date":"2019-12-27T06:33:33.968Z","updated":"2019-12-27T06:33:33.968Z","comments":true,"path":"2019/12/27/盒子模型/","link":"","permalink":"https://linxd1999.github.io/2019/12/27/盒子模型/","excerpt":"","text":"一.盒 CSS处理网页时，认为每个元素都包含在一个不可见的盒子里 我们只要把相应的盒子摆放到网页中相应的位置即可完成对网页的布局 组成： 内容区(content) 内边距(padding) 边框(border) 外边距(margin) 二.边框 width：内容区宽度 height：内容区高度 border-width：边框的宽度 可以分别指定四个边框的宽度(顺时针赋值) 如果指定四个值，则分别设置给上，右，下，左 如果指定三个值，则分别设置给上，左右，下 如果指定两个值，则分别设置给上下，左右 如果指定一个值，则设置给四条边 CSS还提供border-xxx-width，xxx可为top，right，bottom，left border-color：边框的颜色，赋值规则同上 border-xxx-color：xxx可为top，right，bottom，left border-style：边框的样式，赋值规则同上 none：没有边框 solid：实线边框 dotted：点状边框 dashed：虚线边框 double：双线边框 border：边框的简写样式，可同时设置四个边框的样式，且没有任何顺序要求，但是border只能一次性指定四条边，不能分别指定。 border-xxx：可以一次指定一条边的所有属性 三.内边距 内边距指的是盒子的内容区和盒子边框之间的距离，一共有四个方向的内边距 内边距会影响盒子的可见框的大小 盒子可见框的宽度=(border-left-width)+(padding-left)+width+(padding-right)+(border-right-width) padding-top：上内边距的宽度 padding-right：右内边距的宽度 padding-bottom：下内边距的宽度 padding-left：左内边距的宽度 padding可同时设置四个内边距的样式，原理同上 box-sizing属性：border-box(设置的边框和内边距是包含在width内的，内容区的实际宽度=width-(border+padding)的值) 四.外边距 外边距指的是当前盒子与其他盒子之间的距离，不会影响可见框的大小，但会影响盒子的位置 盒子有四个方向的外边距 margin-top：上外边距的宽度 margin-right：右外边距的宽度 margin-bottom：下外边距的宽度 margin-left：左外边距的宽度 margin可同时设置四个方向外边距的样式 由于页面中的元素都是靠左上摆放的，所以当设置上，左外边距时，会导致盒子自身的位置发生改变，设置右，下外边距会改变其他盒子的位置 外边距可以是负值，元素向反方向移动 margin还可以设置auto，一般只设置给水平方向的margin，如果只指定左外边距或右外边距的值为auto则会将外边距设置为最大值；垂直方向如果设置为auto，则默认为0 1234/*盒子居中，两侧外边距设置为相同的值 可以使元素自动在父元素中居中*/margin-left: auto;margin-right: auto; 垂直外边距的重叠：在垂直方向的相邻外边距会发生重叠，兄弟元素之间的相邻外边距会取最大值而不是取和。如果父子元素的垂直外边距相邻了，则子元素的外边距会设置给父元素 浏览器为了在页面中没有样式时，也可以有一个比较好的显示效果，所以为很多元素都设置了默认的margin和padding，而默认样式在正常情况下是不需要的，所以我们需要在设置样式之前把默认样式都去掉 五.内联元素的盒模型 内联元素不能设置width和height 内联元素可以设置水平方向的内边距，边框 内联元素可以设置垂直方向的内边距，边框，但不会影响页面的布局 水平方向的相邻外边距不会重叠，但会求和，内联元素不支持垂直外边距 内联元素和块元素可以相互转换 display样式可修改元素的类型 inline：内联元素 block：块元素 inline-block：行内块元素(使一个元素既有行内元素的特点又有块元素的特点，可设置宽高而不独占一行) none：此元素不显示，且不再占据页面的位置 visibility可修改元素的显示状态 visible：默认值，元素默认在页面显示 hidden：元素会隐藏不显示，但位置会继续保持 overflow属性：设置父元素如何处理子元素溢出的问题 visible：默认值，不对溢出内容做处理，元素会在父元素以外的位置显示 hidden：溢出的内容被修剪，不显示 scroll：会为父元素添加滚动条，通过滚动来查看完整的内容(不论是否溢出，都有水平和垂直的滚动条) auto：会根据需求自动添加滚动条 六.浮动 块元素在文档流中默认垂直排列，如果希望块元素可以脱离文档流，可以用float使块元素浮动从而脱离文档流 float：浮动元素，脱离文档流 none：默认值，元素默认在文档流中排列 left：元素会立即脱离文档流，向页面的左侧浮动 right：元素会立即脱离文档流，向页面的右侧浮动 元素浮动之后，它下边的元素会立即向上移动 元素浮动以后，它会尽量向页面的左上或是右上浮动，直到遇到父元素的边框或者其他的浮动元素 如果浮动元素上边是一个没有浮动的块元素，则浮动元素不会超过块元素 浮动元素不会超过它的兄弟元素，最多一边齐 块元素脱离文档流后，高度和宽度都会被内容撑开 内联元素脱离文档流后会变成块元素 文档流中，父元素的高度默认被子元素撑开。但子元素浮动后，会导致父元素高度塌陷，父元素下的所有元素都向上移动，页面布局混乱 可以将父元素的高度固定，父元素的高度将不能自适应子元素的高度，不推荐使用 设置overflow：(非visible的值) 在高度塌陷的父元素最后添加一个空白的div，由于此div没有浮动，所以可以撑开父元素，然后对它清除左右浮动即可(基本无副作用) 基于上一条，可以通过after伪类，选中父元素的最后边，转化为块元素，再清除浮动 12345.box1:after&#123; content: \"\"; display: block; clear: both;&#125; clear：清除浮动 none：默认值，不清除浮动 left：清除左侧浮动元素对当前元素的影响 right：清除右侧浮动元素对当前元素的影响 both：清除左右浮动元素中对当前元素影响最大的 七.定位 定位是将指定的元素摆放到页面的任意位置，通过定位可以任意的摆放元素 position属性：设置元素的定位 static：默认值，元素没有开启定位 relative：开启元素的相对定位 absolute：开启元素的绝对定位 fixed：开启元素的固定定位(绝对定位的一种) 1.相对定位 position设置成relative时，则开启了元素的相对定位，元素不会脱离文档流，但会使元素提高一个层级，不会改变元素的性质，块还是块，内联还是内联 开启相对定位但不设置偏移量时，元素不会发生任何变化 可以通过left，right，top，bottom四个属性来设置元素的偏移量 left：元素相对于原定位位置的左侧偏移量 right：元素相对于原定位位置的右侧偏移量 top：元素相对于原定位位置的上侧偏移量 bottom：元素相对于原定位位置的下侧偏移量 通常偏移量只需要使用两个就可以对一个元素进行定位，一般选择水平方向的一个偏移量和垂直方向的偏移量来为一个元素进行定位 2.绝对定位 positon设置成absolute时，开启元素的绝对定位，元素会脱离文档流 开启绝对定位但不设置偏移量时，元素位置不变 绝对定位是相对于离他最近的开启了定位的祖先元素进行定位，如果所有的祖先元素都没有开启定位，则相对于浏览器窗口进行定位(一般情况下，开启了子元素的绝对定位都会同时开启父元素的相对定位) 绝对定位会使元素提升一个层级 绝对定位会改变元素的性质，内联元素变成块元素 3.固定定位 position设置为fixed时，开启元素的固定定位 固定定位也是一种绝对定位，大部分特点和绝对定位一样，但有一些不同 固定定位永远相对于浏览器窗口进行定位 固定定位会固定在浏览器窗口的某个位置，不会随滚动条滚动(牛皮癣广告) IE6不支持固定定位 4.元素层级 如果定位元素的层级一样，则下边的元素会盖住上边的 通过z-index属性可设置元素的层级(数字越大，层级越大，越优先显示) 对于没有开启定位的元素不能使用z-index属性 5.透明背景 opacity属性：设置背景的透明度，值为0-1 0表示完全透明 0.5表示半透明 1表示完全不透明 opacity在IE8以下的浏览器不支持，需要用alpha(opacity=透明度)代替 需要一个0-100之间的值 0表示完全透明 100表示完全不透明 50表示半透明","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://linxd1999.github.io/tags/CSS/"},{"name":"Front-End","slug":"Front-End","permalink":"https://linxd1999.github.io/tags/Front-End/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2019-12-27T06:33:33.968Z","updated":"2019-12-27T06:33:33.968Z","comments":true,"path":"2019/12/27/正则表达式/","link":"","permalink":"https://linxd1999.github.io/2019/12/27/正则表达式/","excerpt":"","text":"一、定义和规则 定义：正则表达式是一个非常强大的字符串处理工具，能对字符串进行查找，提取，分割，替换等操作 常用的正则表达式支持字符 裸字符：除了特殊字符，都可以直接匹配 \\uhhhh：Unicode万国码 ()：标记子表达式的位置 []：枚举或范围 {}：字符的出现频率 *：前面子表达式可以出现0或多次，相当于{0,} +：前面子表达式可以出现1或多次，相当于{1,} ?：前面子表达式可以出现0或1次，相当于{0,1} . ：匹配所有除了换行以外的字符 |：或 d是digit，s是space，w是word \\d：匹配0-9的所有数字，\\D是其补集 \\s：匹配空白字符，包括空格，回车，制表，换页等，\\S是其补集 \\w：匹配所有单词字符，包含数字，英文字母，下划线，\\W是其补集 -：范围符 [^]：求否 二、使用需要使用Pattern类和Matcher类 import java.util.regex.Matcher;import java.util.regex.Pattern; Pattern对象是正则表达式编译后在内存中的表示形式，多个Matcher对象可以共享一个Pattern对象 Matcher是匹配器，需要调用Pattern的matcher()结果来执行匹配 常用方法如下： find()：是否包含与正则表达式匹配的子串 group()：返回上一次匹配的子串 start()：返回上一次匹配的子串起始位置 end()：返回上一次匹配的子串结束位置+1 matches()：整个目标字符串与正则表达式是否匹配 reset()：重置匹配器，并可以启用新的需要匹配的字符串 例1：分离字符串中的整数 1234Matcher m = Pattern.compile(\"\\\\d+\").matcher(\"&lt;10|100&gt;\");while(m.find()) &#123; System.out.println(m.group());&#125; 例2：判断邮箱正确性 1234567891011121314151617String [] mails = &#123; \"lxd1999@qq.com\", \"lxd1999@163.com\", \"lxd1999@gmail.cn\", \"as@qq.ws\"&#125;;String RegEx = \"\\\\w&#123;3,20&#125;@\\\\w+\\\\.(com|cn)\";Pattern p = Pattern.compile(RegEx);Matcher m = null;for(String temp : mails) &#123; if(m==null) &#123; m = p.matcher(temp); &#125;else &#123; m.reset(temp); &#125; System.out.println(temp+(m.matches()?\"是\":\"不是\")+\"一个有效的邮件地址\"); &#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://linxd1999.github.io/tags/Java/"}]},{"title":"模拟函数栈实现非递归遍历二叉树","slug":"树的遍历","date":"2019-12-27T06:33:33.953Z","updated":"2019-12-27T06:33:33.953Z","comments":true,"path":"2019/12/27/树的遍历/","link":"","permalink":"https://linxd1999.github.io/2019/12/27/树的遍历/","excerpt":"","text":"一.思想 递归实现的遍历是基于函数栈的不断返回完成的，所以我们也可以用栈这个数据结构来模拟这种函数栈的返回 这种方法可以实现前序，中序，后序遍历写出基本一致的代码，只不过入栈顺序不同 使用颜色标记节点状态，新节点为白色，访问过的节点为灰色。白色意味着继续递归，灰色意味着在函数栈返回时可将该节点存入结果集中 栈顶节点为白色，则将其标记为灰色，然后将其自身，左子节点，右子结点按指定顺序依次入栈 栈顶节点为灰色，则将节点的值输出 例如前序遍历：前序遍历的顺序是根左右，所以入栈顺序就应该是右左根(基于栈的先进后出原则) 参考：力扣题解 代码：代码仓库 二.实现代码 前序遍历 123456789101112131415161718192021222324252627282930class Solution &#123; public enum color&#123; White,Grey; &#125; class isRecursion&#123; color c; TreeNode n; public isRecursion(color c,TreeNode n) &#123; this.c = c; this.n = n; &#125; &#125; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); Stack&lt;isRecursion&gt; s = new Stack&lt;&gt;(); s.push(new isRecursion(color.White,root)); while(!s.isEmpty()) &#123; isRecursion temp = s.pop(); if(temp.n == null) continue; if(temp.c == color.White) &#123; if(temp.n.right != null) s.push(new isRecursion(color.White,temp.n.right)); if(temp.n.left != null) s.push(new isRecursion(color.White,temp.n.left)); s.push(new isRecursion(color.Grey,temp.n)); &#125;else &#123; res.add(temp.n.val); &#125; &#125; return res; &#125;&#125; 中序遍历 123456789101112131415161718192021222324252627282930class Solution &#123; public enum color&#123; White,Grey; &#125; class isRecursion&#123; color c; TreeNode n; public isRecursion(color c,TreeNode n) &#123; this.c = c; this.n = n; &#125; &#125; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); Stack&lt;isRecursion&gt; s = new Stack&lt;&gt;(); s.push(new isRecursion(color.White,root)); while(!s.isEmpty()) &#123; isRecursion temp = s.pop(); if(temp.n == null) continue; if(temp.c == color.White) &#123; if(temp.n.right != null) s.push(new isRecursion(color.White,temp.n.right)); s.push(new isRecursion(color.Grey,temp.n)); if(temp.n.left != null) s.push(new isRecursion(color.White,temp.n.left)); &#125;else &#123; res.add(temp.n.val); &#125; &#125; return res; &#125;&#125; 后序遍历 123456789101112131415161718192021222324252627282930class Solution &#123; public enum color&#123; White,Grey; &#125; class isRecursion&#123; color c; TreeNode n; public isRecursion(color c,TreeNode n) &#123; this.c = c; this.n = n; &#125; &#125; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); Stack&lt;isRecursion&gt; s = new Stack&lt;&gt;(); s.push(new isRecursion(color.White,root)); while(!s.isEmpty()) &#123; isRecursion temp = s.pop(); if(temp.n == null) continue; if(temp.c == color.White) &#123; s.push(new isRecursion(color.Grey,temp.n)); if(temp.n.right != null) s.push(new isRecursion(color.White,temp.n.right)); if(temp.n.left != null) s.push(new isRecursion(color.White,temp.n.left)); &#125;else &#123; res.add(temp.n.val); &#125; &#125; return res; &#125;&#125;","categories":[],"tags":[{"name":"Tree","slug":"Tree","permalink":"https://linxd1999.github.io/tags/Tree/"}]},{"title":"排序算法","slug":"排序","date":"2019-12-27T06:33:33.953Z","updated":"2019-12-27T06:33:33.953Z","comments":true,"path":"2019/12/27/排序/","link":"","permalink":"https://linxd1999.github.io/2019/12/27/排序/","excerpt":"","text":"一.冒泡排序 冒泡排序实质上就是让相邻两个数比较，较大数向右走，每轮可以确定一个最大的数 123456789101112131415161718192021222324252627public class BubbleSort &#123; public static void main(String[] args) &#123; int arr[] = &#123;3,9,-1,10,-2&#125;; bubbleSort(arr); System.out.println(Arrays.toString(arr)); &#125; public static void bubbleSort(int []arr) &#123; int temp = 0; boolean f = false; //冒泡排序的时间复杂度:O(n^2) for(int i = 0; i &lt; arr.length-1; i++) &#123; for(int j = 0; j &lt; arr.length-1-i; j++) &#123; if(arr[j]&gt;arr[j+1]) &#123; f = true; temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; if(f == false) &#123; break; &#125;else &#123; f = false; &#125; &#125; &#125;&#125; 二.选择排序 选择排序的实质就是每轮选出一个最小的数放到数组的最前面 1234567891011121314151617181920212223public class SelectSort &#123; public static void main(String[] args) &#123; int arr[] = &#123;3,9,-1,10,-2&#125;; selectSort(arr); System.out.println(Arrays.toString(arr)); &#125; public static void selectSort(int []arr) &#123; for(int i = 0; i &lt; arr.length-1; i++) &#123; int min = arr[i]; int minIndex = i; for(int j = i+1;j&lt;arr.length; j++) &#123; if(min &gt; arr[j]) &#123; min = arr[j]; minIndex = j; &#125; &#125; if(minIndex != i) &#123; arr[minIndex] = arr[i]; arr[i] = min; &#125; &#125; &#125;&#125; 三.插入排序 插入排序就是把数组分成一个无序表和一个有序表，第一个有序表是第一个元素，然后每轮把后一个元素插入合适的位置使整个数组都变为有序表 123456789101112131415161718192021222324public class InsertSort &#123; public static void main(String[] args) &#123; int arr[] = &#123;3,9,-1,10,-2&#125;; insertSort(arr); System.out.println(Arrays.toString(arr)); &#125; public static void insertSort(int [] arr) &#123; int insertVal = 0; int insertIndex = 0; for(int i = 1; i &lt; arr.length; i++) &#123; insertVal = arr[i]; insertIndex = i-1;// 给insertVal找插入的位置 while(insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) &#123; arr[insertIndex+1] = arr[insertIndex]; insertIndex--; &#125; //当退出循环时，插入位置找到,insertIndex+1 if(insertIndex+1 != i) &#123; arr[insertIndex+1] = insertVal; &#125; &#125; &#125;&#125; 四.希尔排序 插入排序中，小的数如果在很后面的话，每次都要移动很长的距离 所以为了解决这个问题，希尔排序使用了一种增量，每次排序都在宏观上把小数往前移，可以使较小的数都出现在数组前部，然后每轮缩小增量直至增量为1。 分为交换式和移位式，移位式效率更高。 12345678910111213141516171819202122232425262728293031323334353637383940414243public class ShellSort &#123; public static void main(String[] args) &#123; int arr[] = &#123; 8, 9, 1, 7, 2, 3, 5, 4, 6, 0 &#125;; //shellSort1(arr); //shellSort2(arr); &#125; // 交换式 public static void shellSort1(int[] arr) &#123; int temp = 0; for (int gap = arr.length / 2; gap &gt; 0; gap /= 2) &#123; for (int i = gap; i &lt; arr.length; i++) &#123; for (int j = i - gap; j &gt;= 0; j -= gap) &#123; if (arr[j] &gt; arr[j + gap]) &#123; temp = arr[j]; arr[j] = arr[gap + j]; arr[gap + j] = temp; &#125; &#125; &#125; System.out.println(Arrays.toString(arr)); &#125; &#125; // 移位式 public static void shellSort2(int[] arr) &#123; int temp = 0; for (int gap = arr.length / 2; gap &gt; 0; gap /= 2) &#123; for (int i = gap; i &lt; arr.length; i++) &#123; int j = i; temp = arr[i]; if (arr[j] &lt; arr[j - gap]) &#123; while (j - gap &gt;= 0 &amp;&amp; temp &lt; arr[j - gap]) &#123; arr[j] = arr[j - gap]; j -= gap; &#125; arr[j] = temp; &#125; &#125; System.out.println(Arrays.toString(arr)); &#125; &#125;&#125;","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://linxd1999.github.io/tags/Algorithm/"}]},{"title":"Common Words and Phrases","slug":"常用单词和词组整理","date":"2019-12-27T06:33:33.937Z","updated":"2019-12-27T06:33:33.937Z","comments":true,"path":"2019/12/27/常用单词和词组整理/","link":"","permalink":"https://linxd1999.github.io/2019/12/27/常用单词和词组整理/","excerpt":"一、常用单词 中 英 统治 govern reign 推动、促进 promote boost facilitate 蓬勃发展 boom mushroom surge flourish thrive 兴荣的 prosperous booming thriving flourishing 稳定的 stable steady 大量、许多 multiple numerous 交易 deal(n.) trade(v.) 发行 publish(书、报纸) issue(钱/股票) 政府(管理) government administration 超过 exceed surpass 领域 field domain territory 激增 balloon soar multiply 骤降 plunge 显著的 notable noticeable remarkable prominent conspicuous 危险 risk danger jeopardy 处理、解决 solve settle tackle 加速 accelerate hasten 获得、收获 gain reap 破坏 destory devastate disrupt 观众 audience spectator 刺激、鼓舞 stimulate(stimulus) spur motivate 商品 goods commodity merchandise 成功的 successful triumphant 重要的 critical significant essential vital crucial 灿烂的 brilliant splendid glorious marvellous fascinating 同时 meanwhile simultaneously 著名的 famous celebrated noted renowned 比赛 competition race(运动) event(运动) 因此 therefore hence 渴望 long crave yearn 目的 purpose aim sake 实施、执行 implement execute 撤退 withdraw retreat 悲惨的 tragic miserable bleak(惨淡的) 缺点 defect flaw weakness shortcoming disadvantage 消失 disappear vanish 保证 promise guarantee pledge 预示 indicate herald anticipate 公平 justice fairness 面对 face confront 忽视、忽略 neglect overlook ignore 预测 predict forecast 分配 allocate allot assign 诱惑 tempt lure 巨大的 huge enormous tremendous massive 足够的 enough adequate sufficient 相同的 same uniform identical 驱使，引发 trigger provoke propel 削减 cut down cripple 剥夺 deprive strip 授权 authorize empower 让步、妥协 compromise concession","text":"一、常用单词 中 英 统治 govern reign 推动、促进 promote boost facilitate 蓬勃发展 boom mushroom surge flourish thrive 兴荣的 prosperous booming thriving flourishing 稳定的 stable steady 大量、许多 multiple numerous 交易 deal(n.) trade(v.) 发行 publish(书、报纸) issue(钱/股票) 政府(管理) government administration 超过 exceed surpass 领域 field domain territory 激增 balloon soar multiply 骤降 plunge 显著的 notable noticeable remarkable prominent conspicuous 危险 risk danger jeopardy 处理、解决 solve settle tackle 加速 accelerate hasten 获得、收获 gain reap 破坏 destory devastate disrupt 观众 audience spectator 刺激、鼓舞 stimulate(stimulus) spur motivate 商品 goods commodity merchandise 成功的 successful triumphant 重要的 critical significant essential vital crucial 灿烂的 brilliant splendid glorious marvellous fascinating 同时 meanwhile simultaneously 著名的 famous celebrated noted renowned 比赛 competition race(运动) event(运动) 因此 therefore hence 渴望 long crave yearn 目的 purpose aim sake 实施、执行 implement execute 撤退 withdraw retreat 悲惨的 tragic miserable bleak(惨淡的) 缺点 defect flaw weakness shortcoming disadvantage 消失 disappear vanish 保证 promise guarantee pledge 预示 indicate herald anticipate 公平 justice fairness 面对 face confront 忽视、忽略 neglect overlook ignore 预测 predict forecast 分配 allocate allot assign 诱惑 tempt lure 巨大的 huge enormous tremendous massive 足够的 enough adequate sufficient 相同的 same uniform identical 驱使，引发 trigger provoke propel 削减 cut down cripple 剥夺 deprive strip 授权 authorize empower 让步、妥协 compromise concession 规模：scale 大规模的：large-scale / mass 城市化：urbanization 边界/界限：boundary 边境/国界：border 大都市：metropolis 禁止：inhibit 栖息、居住于：inhabit 展示、展览：exhibit 把…归咎于：attribute 贡献：contribute 阻碍：hinder 可行的：feasible 合理的：rational 不合理的：irrational 无理由的：groundless 学科类 数学 mathematics 科学 science 哲学 philosophy 物理 physics 心理学 psychology 化学 chemistry 生物 biology 生物化学 biochemisty 政治 politics 文学 literature 体育 gymnastics 地理 geography 农业类 农业 agriculture 机械 machinery 农作物 crop 小麦 wheat 豆类 beans 水稻 rice 可开垦的 arable 耕作 cultivation 肥料 fertilizer 产量 yield 生产力(率) productivity 有机的 organic 无机的 inorganic 经济类 通货膨胀 inflation 波动 fluctuate 大幅削减 slash 基金 fund/capital 环境类 温室的 greenhouse 排放 emission 易受伤的 vulnerable 化石燃料 fossil fuel 负担 burden 生活类 体温计 thermometer 旗舰店 flagship store 所有物，财产 property 机构 agency 生的 raw 仓库 repository journal 旅游 journey 态度类 有野心的 ambitious 不情愿的 reluctant 模糊的 ambiguous 开明的 liberal 中立的 neutral 失望的 disappointed 二、常用词组占地…面积：with a area of / cover a area of 平方米(千米)：square meter(kilometer) 表范围：range in 长度/宽度/大小 from … to … 海拔：1000 meters above the sealevel / at an altitude of 1000 meters 在…西边多远：100 kilometers west of … 来源于… ：originate from… 追溯到：trace back to / date back to 另一方面：on the other hand / on the flip side","categories":[],"tags":[{"name":"English","slug":"English","permalink":"https://linxd1999.github.io/tags/English/"}]},{"title":"内存分页和分段","slug":"内存管理","date":"2019-12-27T06:33:33.921Z","updated":"2019-12-27T06:33:33.921Z","comments":true,"path":"2019/12/27/内存管理/","link":"","permalink":"https://linxd1999.github.io/2019/12/27/内存管理/","excerpt":"","text":"","categories":[],"tags":[{"name":"OS","slug":"OS","permalink":"https://linxd1999.github.io/tags/OS/"}]},{"title":"二叉树","slug":"二叉树","date":"2019-12-27T06:33:33.921Z","updated":"2019-12-27T06:33:33.921Z","comments":true,"path":"2019/12/27/二叉树/","link":"","permalink":"https://linxd1999.github.io/2019/12/27/二叉树/","excerpt":"","text":"重构二叉树 前序遍历+中序遍历 后序遍历+中序遍历 真二叉树(没有度为1的节点)，结果唯一 前驱节点，后继节点1.前驱节点 前驱节点(predecessor)：中序遍历的前一个节点 二叉搜索树，前驱节点就是前一个比他小的节点 寻找前驱节点 node.left != null，predecessor=node.left.right.right…(终止条件：right为null) node.left == null &amp;&amp; node.parent !=null，predecessor=node.parent.parent…(终止条件：node在parent的右子树中) node.left == null &amp;&amp; node.parent ==null，没有前驱节点 123456789101112131415161718public Node&lt;E&gt; predecessor(Node&lt;E&gt; node)&#123; if(node == null) return null; //前驱节点在左子树中(left.right.right.right...) if (node.left!=null)&#123; Node&lt;E&gt; p = node.left; while (p.right!=null)&#123; p = p.right; &#125; return p; &#125; //从父节点，祖父节点中寻找前驱节点 while (node.parent!=null &amp;&amp; node == node.parent.left)&#123; node = node.parent; &#125; //node.parent == null //node == node.parent.right return node.parent;&#125; 2.后继节点 后继节点(successor)：中序遍历的后一个节点 二叉搜索树，后继节点就是后一个比它大的节点 寻找后继节点 node.right != null，predecessor=node.right.left.left…(终止条件：left为null) node.right == null &amp;&amp; node.parent !=null，successor=node.parent.parent…(终止条件：node在parent的左子树中) node.right == null &amp;&amp; node.parent ==null，没有后继节点 123456789101112131415161718public Node&lt;E&gt; successor(Node&lt;E&gt; node)&#123; if(node == null) return null; //后继节点在左子树中(left.right.right.right...) if (node.right!=null)&#123; Node&lt;E&gt; p = node.right; while (p.left!=null)&#123; p = p.left; &#125; return p; &#125; //从父节点，祖父节点中寻找后继节点 while (node.parent!=null &amp;&amp; node == node.parent.right)&#123; node = node.parent; &#125; //node.parent == null //node == node.parent.left return node.parent;&#125;","categories":[],"tags":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://linxd1999.github.io/tags/DataStructure/"},{"name":"Tree","slug":"Tree","permalink":"https://linxd1999.github.io/tags/Tree/"}]},{"title":"JDBC编程","slug":"jdbc","date":"2019-12-27T06:33:33.906Z","updated":"2019-12-27T06:33:33.906Z","comments":true,"path":"2019/12/27/jdbc/","link":"","permalink":"https://linxd1999.github.io/2019/12/27/jdbc/","excerpt":"","text":"一、JDBC简介JDBC(Java Database Connectivity):JAVA数据库连接，是可以执行sql语句的一套API 程序可通过JDBC连接到关系数据库，用sql对数据进行增删改查 通过JDBC开发的数据库应用可跨平台 数据库驱动程序：JDBC与数据库之间的转换层，负责将JDBC调用映射成特定的数据库调用 二、JDBC编程1.常用类和接口DriverManager：用于管理JDBC驱动的服务类，用于获取Connection对象 Connection：数据库连接对象，每个Connection代表一个连接会话。它是一个接口，可通过Statement，Preparedstatement来实例化，获取其对象 Statement：用于执行sql的工具接口 PreparedStatement：预编译的Statement对象，是Statement子接口，可以预编译sql语句，允许sql语句含参，方便后来修改也可避免每次都编译sql语句，性能好。 Statement和PreparedStatement都有execute()，executeUpdate()，executeQuery()，返回查询的结果集，executeUpdate()可执行DML语句，返回受影响的行数，executeQuery()可以执行DDL语句，返回结果集对象，所以一般不用execute()方法，返回的是ResultSet结果集。 ResultSet：结果集对象，包含很多查询结果的方法，可以根据列名或列索引来获取结果，也有很多种方法来移动记录指针，最常用的是next()方法。 2.步骤(以MySQL为例)123Connection conn = null;PreparedStatement pstmt = null;ResultSet rs = null; (1).加载数据库驱动1Class.forName(\"com.mysql.cj.jdbc.Driver\"); (2).获取数据库连接1conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/test?useSSL=false&amp;serverTimezone=UTC\",\"root\", \"password\"); (3).通过Connection创建PreparedStatement对象1pstmt = conn.prepareStatement(sql); (4).执行sql语句12rs = pstmt.executeQuery();result = pstmt.executeUpdate; 三、模板这些语句都可以被封装成单独的函数进行使用，更加方便，不用每次再进行定义。 下面是DAO模式分层后，最底层与数据库交互的BaseDao类，方便再使用时拷贝， 连接数据库还需要一个.property文件，里面记录了驱动，数据库位置，用户和密码，每次使用只需要改这里就可以 1234driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/test?useSSL=false&amp;serverTimezone=UTCuser=rootpassword=123456 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133/** * 数据库连接与关闭工具类。 */public class BaseDao &#123; public static String DRIVER; // 数据库驱动 public static String URL ; // url public static String DBNAME; // 数据库用户名 public static String DBPASS; // 数据库密码 Connection conn = null;// 数据连接对象 static&#123;//静态代码块,在类加载的时候执行 init(); &#125; /** * 初始化连接参数,从配置文件里获得 */ public static void init()&#123; Properties params=new Properties(); String configFile = \"database.properties\";//配置文件路径 //加载配置文件到输入流中 InputStream is=BaseDao.class.getClassLoader().getResourceAsStream(configFile); try &#123; //从输入流中读取属性列表 params.load(is); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //根据指定的获取对应的值 DRIVER=params.getProperty(\"driver\"); URL=params.getProperty(\"url\"); DBNAME=params.getProperty(\"user\"); DBPASS=params.getProperty(\"password\"); &#125; /** * 得到数据库连接 * * @throws ClassNotFoundException * @throws SQLException * @return 数据库连接 */ public Connection getConnection() throws ClassNotFoundException, SQLException &#123; Connection conn = null; try &#123; Class.forName(DRIVER); // 注册驱动 conn = DriverManager.getConnection(URL, DBNAME, DBPASS); // 获得数据库连接 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return conn; // 返回连接 &#125; /** * 释放资源 * * @param conn * 数据库连接 * @param pstmt * PreparedStatement对象 * @param rs * 结果集 */ public void closeAll(Connection conn, PreparedStatement pstmt, ResultSet rs) &#123; /* 如果rs不空，关闭rs */ if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /* 如果pstmt不空，关闭pstmt */ if (pstmt != null) &#123; try &#123; pstmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /* 如果conn不空，关闭conn */ if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 执行SQL语句，可以进行增、删、改的操作，不能执行查询 * * @param sql * 预编译的 SQL 语句 * @param param * 预编译的 SQL 语句中的‘？’参数的字符串数组 * @return 影响的条数 */ public int executeSQL(String preparedSql, Object[] param) &#123; Connection conn = null; PreparedStatement pstmt = null; int num = 0; /* 处理SQL,执行SQL */ try &#123; conn = getConnection(); // 得到数据库连接 pstmt = conn.prepareStatement(preparedSql); // 得到PreparedStatement对象 if (param != null) &#123; for (int i = 0; i &lt; param.length; i++) &#123; pstmt.setObject(i + 1, param[i]); // 为预编译sql设置参数 &#125; &#125; num = pstmt.executeUpdate(); // 执行SQL语句 &#125; catch (ClassNotFoundException e) &#123; //e.printStackTrace(); // 处理ClassNotFoundException异常 &#125; catch (SQLException e) &#123; //e.printStackTrace(); // 处理SQLException异常 &#125; finally &#123; this.closeAll(conn, pstmt, null); &#125; return num; &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://linxd1999.github.io/tags/Java/"}]},{"title":"","slug":"Set&Map","date":"2019-12-27T06:33:33.890Z","updated":"2019-12-27T06:33:33.890Z","comments":true,"path":"2019/12/27/Set&Map/","link":"","permalink":"https://linxd1999.github.io/2019/12/27/Set&Map/","excerpt":"","text":"集合(Set) 不能存放重复的元素 一般用于去重 存放新增ip，统计新增ip量 存放词汇，统计词汇量 接口 12345678910111213public interface Set&lt;E&gt; &#123; int size(); boolean isEmpty(); void clear(); boolean contains(E element); void add(E element); void remove(E element); void traversal(Visitor&lt;E&gt; visitor); public static abstract class Visitor&lt;E&gt; &#123; boolean stop; public abstract boolean visit(E element); &#125;&#125; 可使用：动态数组(ArrayList)，链表(LinkedList)，AVL树，红黑树等来实现Set集合 1.TreeSet ListSet底层用链表实现，TreeSet底层用红黑树实现。 TreeSet性能优于ListSet JDK中没有ListSet TreeSet缺陷：元素必须具备可比较性 2.HashSet3.LinkedHashSet映射(Map) 在有些语言中也叫字典(dictionary) Map的每个key是唯一的，对应一个value(键值对) Map也可以用链表，二叉搜索树(AVL，红黑树)等数据结构来实现 接口 123456789101112131415public interface Map&lt;K,V&gt; &#123; int size(); boolean isEmpty(); void clear(); V put(K key,V value); V get(K key); V remove(K key); boolean containsKey(K key); boolean containsValue(V value); void traversal(Visitor&lt;K,V&gt; visitor); public static abstract class Visitor&lt;K,V&gt;&#123; boolean stop; public abstract boolean visit(K key, V value); &#125;&#125; 1.TreeMap 实现 可以用内部类封装键值对，但不好用 在把TreeSet类当成红黑树类来实现，节点中存储&lt;K,V&gt;的键值对 TreeMap中的key集合就是一个TreeSet。所以TreeMap可以转化成TreeSet 节点中存储的数据为&lt;E,Object&gt;，其中Object赋值为空对象 会造成性能(空间)浪费 优点：可以把Set和Map代码集成起来，减少代码量 平均时间复杂度：添加，搜索，删除都是O(logn) 如果不考虑Map中存储元素的顺序和key的可比较性，有更好的实现方案，哈希表可以将时间复杂度缩小到O(1) 2.HashMap3.LinkedHashMap哈希表1.哈希表 哈希表也叫散列表 添加，搜索，删除的流程类似 利用哈希函数生成的key对应的index[O(1)] 根据index操作定位数组元素[O(1)] 哈希表是典型的以空间换时间的应用 哈希表内部的数组元素，也称为Bucket(桶) 2.哈希冲突 哈希冲突(Hash Collision)：也叫哈希碰撞，2个或以上不同的key，经过哈希函数计算出相同的结果 解决 开放定址法：按照一定规则向其他地址探测，直到遇到空桶 再哈希法：设计多个哈希函数 链地址法：通过链表将同一个index的元素串起来 JDK1.8的哈希冲突解决方案(单向链表+红黑树) 默认使用单向链表将元素串起来 在添加元素时，可能会由单向链表转为红黑树来存储元素；在红黑树节点少到一定程度时，又转化成单向链表 使用单向链表的原因：每次都从头开始遍历，key值相等覆盖，相比于双向链表少一个指针，节省内存空间 3.哈希函数 哈希函数：生成元素存储的索引值 先生成key的哈希值(必须是整数) 再让key的哈希值跟数组的大小进行相关运算，生成一个索引值 为了提高效率，可以使用&amp;位运算取代&amp;运算(前提：数组长度为2的幂) 12345678public int hash(Object key)&#123; return hash_code(key) % table.length;&#125;//改良版本public int hash(Object key)&#123; return hash_code(key) &amp; (table.length-1);&#125; 数组长度为2^n，则2^n-1二进制为全1。无论key的值多大，&amp;(2^n-1)的结果范围都是0-2^n-1。 如果执意想用%来算索引值，将数组长度设计为素数，可以大大减少哈希冲突 良好的哈希函数：让哈希值分布更均匀，减少哈希冲突次数，提升哈希表性能 4.hashCode() key的常见种类：整数，浮点数，字符串，自定义对象 不同种类的key，哈希值的生成方式不同，但目标一致 尽量让每个key的哈希值唯一 尽量让key的所有信息参与运算 整数：整数值当做哈希值 浮点数：将存储的二进制格式转为整数值，floatToIntBits(value) Long和Double类型：让前32位二进制位和后32位二进制位混合运算 1234567891011public static int hashCode(long value)&#123; return (int)(value ^ (value &gt;&gt;&gt; 32));&#125;public static int hashCode(double value)&#123; long bits = doubleToLongBits(value); return (int)(value ^ (value &gt;&gt;&gt; 32));&#125;//^：异或运算符(使用&amp;，|都会使数据不能充分混合计算，容易出现全0或全1的情况)//异或运算符的作用：保证对象有一位改变则哈希值就会改变，index进而改变，尽可能减少碰撞//&gt;&gt;&gt;：无符号右移，剩下用0填充 字符串：字符串由若干字符组成，而字符的本质就是整数 5489 = 5 10^3+4 10^2+8 10^1 +9 10^0 jack = j n^3+a n^2+c n^1 +k n^0 = [(j n+a) n+c] *n+k 在JDK中，乘数n=31,31是一个奇素数，JVM会将31 *i优化成(i&lt;&lt;5)-i 自定义对象：默认哈希值由内存地址决定，内存地址相同的对象哈希值才相同。这意味着两个不同的对象，对象内的所有内容都相同，但这两个对象的哈希值是不同的。所以实际开发中需要重写对象的hashCode()方法 哈希值相同，索引一定相同；哈希值不同，索引也可能相同 扰动计算：尽量运用前一半二进制位和后一半二进制位做异或运算，提高key分布的稳定性 5.equals() 用于比较：发生哈希冲突时，两个对象的key是否相同(决定是否覆盖) 同时实现hashCode()和equals()方法才能使哈希表稳定 只实现equals()：hashCode()不同但是索引可能相同，如果索引相同且对象类型、存储数据都相同，这两个对象会被哈希表存储在同一个位置(相互覆盖)，但是几率很小，所以这种哈希表不稳定 只实现hashCode()：如果不实现equals()，默认只当两个对象内存地址相同时，两个对象才相等。所以两个对象类型、存储数据都相同的对象会被存放在哈希表同一个索引下的不同位置 如果自定义对象要作为哈希表的key，则hashCode()，equals()都必须实现 两个对象是否相等取决于需求，可能成员变量不用完全相同也可以判定为两个对象相等 性质 自反性：对于任何非 null 的 x，x.equals(x)必须返回true 对称性：对于任何非 null 的 x、y，如果 y.equals(x) 返回 true，x.equals(y) 必须返回 true 传递性：对于任何非 null 的 x、y、z，如果 x.equals(y)、y.equals(z) 返回 true，那么x.equals(z) 必须 返回 true 一致性：对于任何非 null 的 x、y，只要 equals 的比较操作在对象中所用的信息没有被修改，多次调用 x.equals(y) 就会一致地返回 true，或者一致地返回 false 对于任何非 null 的 x，x.equals(null) 必须返回 false 6.添加、查找 添加和查找都需要利用key找到hashCode，进而找到index。然后在红黑树上考虑插入某处位置 哈希表的元素可为不同类型，可为空对象，也可以是不可比较的 7.扩容 装填因子(Load Factor)：节点总数量/哈希表桶数组长度，也叫负载因子 JDK1.8的HashMap中，装填因子超过0.75，数组长度扩容为原来两倍 当扩容为原来容量的两倍时，节点的索引有两种情况 保持不变 index = index + table.length(旧数组长度) 每次插入元素时先判断，如果装填因子超过0.75，则进行扩容 8.HashMap和TreeMap TreeMap: O(logn) HashMap: O(1)，由于哈希值处理，负载因子等原因，树高很小，可认为定位的时间复杂度为O(1) 选择TreeMap：元素具备可比较性且要求升序遍历(元素从小到大) 选择HashMap：无序遍历 LinkedHashMap 在HashMap的基础上维护元素的添加顺序，使得遍历的结果是遵从添加顺序的","categories":[],"tags":[]},{"title":"String、StringBuffer、StringBuilder类","slug":"String、StringBuffer、StringBuilder类","date":"2019-12-27T06:33:33.890Z","updated":"2019-12-27T06:33:33.890Z","comments":true,"path":"2019/12/27/String、StringBuffer、StringBuilder类/","link":"","permalink":"https://linxd1999.github.io/2019/12/27/String、StringBuffer、StringBuilder类/","excerpt":"","text":"一.字符串常量池字符串常量池属于Java的静态常量池，即.class文件中的常量池，占用class文件的大部分空间，还保存一些类、方法、接口中的常量。 String.intern()方法：查找常量池中是否存在该字符串，若存在则返回字符串的引用，若不存在则把该字符串添加进常量池并返回引用。 “abc”和new String(“abc”)的区别 在编译时候就能计算出的字符串值，JVM用常量池管理这些字符串 new一个字符串时，先用常量池管理该字符串，然后再用构造器创建一个新String对象，保存在堆内存中，共产生两个对象 常量池保证相同的字符串直接量只有一个，可以多个引用指向同一个常量。 常量池避免频繁创建销毁对象，实现对象共享，节省内存和运行时间。 12345678910String s1 = \"abc\";String s2 = \"ab\" + \"c\";String s3 = \"ab\";String s4 = \"c\";String s5 = s3 + s4;String s6 = new String(\"abc\");System.out.println(s1 == s2);//trueSystem.out.println(s1 == s5);//falseSystem.out.println(s1 == s5.intern());//trueSystem.out.println(s1 == s6);//false ==表示比较两个引用变量指向的地址。 s1 == s2：编译器会在编译期间自动把已知字符串拼接好，并放入常量池 s1 != s5：s5不能在编译期间确定，地址不能确定 s1 == s5.intern()：intern方法检测出s5内容存在于常量池中，返回字符串引用 s1 != s6：构造器生成的字符串编译时地址不能确定 二.StringBuffer和StringBuilderStringBuffer对象是一个字符序列可变的字符串 StringBuilder是JDK1.5之后新增的类，操作和StringBuffer基本一样 这两个类都解决了大量拼接字符串时产生很多中间对象而影响性能的问题 区别：StringBuffer线程安全，效率低；StringBuilder线程不安全，效率高，所以StringBuilder使用的多，尤其是单线程应用。 123456789101112131415StringBuilder sb = new StringBuilder();for(int i = 0; i &lt; 26; i++) &#123; sb.append((char)('a'+i));&#125;System.out.println(sb);//abcdefghijklmnopqrstuvwxyzSystem.out.println(sb.hashCode());//664740647sb.reverse();System.out.println(sb);//zyxwvutsrqponmlkjihgfedcbaSystem.out.println(sb.hashCode());//664740647sb.setCharAt(0, 'A');System.out.println(sb);//Ayxwvutsrqponmlkjihgfedcbasb.insert(1, \"bcd\");System.out.println(sb);//Abcdyxwvutsrqponmlkjihgfedcbasb.delete(0, 4);System.out.println(sb);//yxwvutsrqponmlkjihgfedcba 几个常用方法： append()：追加 reverse()：倒序 setCharAt()：修改某位置字符 setLength()：设置字符串长度 insert()：在某位置添加字符或字符串 delete()：删除某位置的字符","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://linxd1999.github.io/tags/Java/"}]},{"title":"","slug":"List","date":"2019-12-27T06:33:33.875Z","updated":"2019-12-27T06:33:33.875Z","comments":true,"path":"2019/12/27/List/","link":"","permalink":"https://linxd1999.github.io/2019/12/27/List/","excerpt":"","text":"一.链表1.复杂度分析O后面不是参数，是数据规模 1.1 数组数组的随机访问速度非常快，elements[n]的效率与n是多少无关 最好情况复杂度：增O(1)，删O(1)，改O(1)，查O(1) 最坏情况复杂度：增O(n)，删O(n)，改O(1)，查O(1) 平均情况复杂度：增O(n)，删O(n)，改O(1)，查O(1) 1.2 链表 最好情况复杂度：增O(1)，删O(1)，改O(1)，查O(1) 最坏情况复杂度：增O(n)，删O(n)，改O(n)，查O(n) 平均情况复杂度：增O(n)，删O(n)，改O(n)，查O(n) 链表指针的定位，时间复杂度较大；但是在需要处理数据的时候，复杂度只需要O(1)，因为不需要移动元素位置","categories":[],"tags":[]},{"title":"Java常用类","slug":"Java常用类","date":"2019-12-27T06:33:33.875Z","updated":"2019-12-27T06:33:33.875Z","comments":true,"path":"2019/12/27/Java常用类/","link":"","permalink":"https://linxd1999.github.io/2019/12/27/Java常用类/","excerpt":"","text":"一.字符串1.String类 String用一对” “来表示 String声明为final，不可被继承 String实现了Serializable接口：字符串支持序列化；实现Comparable接口：字符串可比较大小 String内部定义了final char[] value用于存储字符串数据 字符序列不可变(不可变性) 当字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值 当对现有字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的字符串对象 当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域 通过字面量的方式赋值(区别于new)，此时字符串值声明在字符串常量池中 字符串常量池不会存储内容相同的字符串 字面量定义和new+构造器定义的字符串有什么区别 字面量定义的字符串存储在常量池中；new的字符串对象在堆中生成，然后在常量池中生成相应的字符串常量，堆中对象指向常量池中的字符串。如果常量池中存在相应字符串，则new的字符串只需要创建一个对象。 常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量，只要其中有一个是变量，结果就在堆中。加了final关键字的字符串是常量。 String.intern()方法：将常量池中已经存在的字符串String的内容返回出来 123456789101112131415161718String s1 = \"abc\";String s2 = \"def\";String s3 = \"abcdef\";String s4 = \"abc\" + \"def\";String s5 = s1 + \"def\";String s6 = \"abc\" + s2;String s7 = s1 + s2; System.out.println(s3 == s4);//trueSystem.out.println(s3 == s5);//falseSystem.out.println(s3 == s6);//falseSystem.out.println(s3 == s7);//falseSystem.out.println(s5 == s6);//falseSystem.out.println(s5 == s7);//falseSystem.out.println(s6 == s7);//false String s8 = s5.intern();System.out.println(s3 == s8);//true 2.String常用方法 int length()：返回字符串的长度： return value.length char charAt(int index)： 返回某索引处的字符return value[index] boolean isEmpty()：判断是否是空字符串：return value.length == 0 String toLowerCase()：使用默认语言环境，将 String 中的所有字符转换为小写 String toUpperCase()：使用默认语言环境，将 String 中的所有字符转换为大写 String trim()：返回字符串的副本，忽略前导空白和尾部空白 boolean equals(Object obj)：比较字符串的内容是否相同 boolean equalsIgnoreCase(String anotherString)：与equals方法类似，忽略大 小写 String concat(String str)：将指定字符串连接到此字符串的结尾。 等价于用“+” int compareTo(String anotherString)：比较两个字符串的大小 String substring(int beginIndex)：返回一个新的字符串，它是此字符串的从 beginIndex开始截取到最后的一个子字符串。 String substring(int beginIndex, int endIndex) ：返回一个新字符串，它是此字 符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。 boolean endsWith(String suffix)：测试此字符串是否以指定的后缀结束 boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始 boolean startsWith(String prefix, int toffset)：测试此字符串从指定索引开始的 子字符串是否以指定前缀开始 boolean contains(CharSequence s)：当且仅当此字符串包含指定的 char 值序列 时，返回 true int indexOf(String str)：返回指定子字符串在此字符串中第一次出现处的索引 int indexOf(String str, int fromIndex)：返回指定子字符串在此字符串中第一次出 现处的索引，从指定的索引开始 int lastIndexOf(String str)：返回指定子字符串在此字符串中最右边出现处的索引 int lastIndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后 一次出现处的索引，从指定的索引开始反向搜索 注：indexOf和lastIndexOf方法如果未找到都是返回-1 String replace(char oldChar, char newChar)：返回一个新的字符串，它是 通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。 String replace(CharSequence target, CharSequence replacement)：使 用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串 String replaceAll(String regex, String replacement)：使用给定的replacement 替换此字符串所有匹配给定的正则表达式的子字符串。 String replaceFirst(String regex, String replacement)：使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。 boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式 String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串。 String[] split(String regex, int limit)：根据匹配给定的正则表达式来拆分此 字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中 3.转换 String和基本数据类型、包装类之间的转换 String转换为基本数据类型、包装类：调用包装类的静态方法parsexxx(str) 基本数据类型、包装类转换为String：调用String重载的valueOf(xxx) or + “ “(拼接空串) String和char[ ]之间的转换 String转换为char[ ]：调用String.toCharArray() char[ ]转换为String：调用new String(char [ ])构造器 String和Byte[ ]之间的转换 String转换为Byte[ ]：调用String.getBytes([“字符集”]) Byte[ ]转换为String：调用new String(Byte [ ],[]”字符集”])构造器 编码：字符串=&gt;字节(看得懂=&gt;看不懂的二进制数据) 解码：字节=&gt;字符串(看不懂的二进制数据=&gt;看得懂的字符串) 乱码：编码集和解码集不一致 4.StringBuffer和StringBuilder JDK5.0新增类 String，StringBuffer，StringBuilder异同 String：不可变字符序列，底层用char[ ]存储 StringBuffer：可变字符序列，线程安全，效率低，底层用char[ ]存储 StringBuilder：可变字符序列，线程不安全，效率高，底层用char[ ]存储 二.比较器1.自然排序：Comparable接口 像String、包装类等实现了Comparable接口，重写了compareTo(obj)方法，给出了比较两个对象的方式 像String、包装类等重写了compareTo()以后，进行从小到大的排列 重写compareTo(obj)的规则 如果当前对象this大于形参对象obj，则返回正整数 如果当前对象this小于形参对象obj，则返回负整数 如果当前对象this等于形参对象obj，则返回0 对于自定义类，如果需要排序，需要实现Comparable接口，重写compareTo()方法 2.定制排序：Comparator接口 当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码， 或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那 么可以考虑使用 Comparator 的对象来排序 重写compare(Object o1,Object o2)方法，比较o1和o2的大小 o1 &gt; o2，返回正整数 o1 &lt; o2，返回负整数 o1 == o2，返回0 区别 Comparable是一个类使用的接口，能保证实现这个类的对象在任何位置都可以比较大小，而Comparator接口属于临时比较，有特定要求的排序才会临时使用，一般可以用内部类和匿名类来实现 为了保证一个类的对象可以有多样的排序方式，可以同时使用这两种接口。如果传入Comparator接口对象作为参数，则按照定制排序的内容进行排序，如果没有传入Comparator接口对象，则把对象强制转换为Comparable接口类型来进行自然排序 123456private int compare(E e1,E e2)&#123; if (comparator!=null)&#123; return comparator.compare(e1,e2); &#125; return ((Comparable&lt;E&gt;)e1).compareTo(e2); &#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://linxd1999.github.io/tags/Java/"}]},{"title":"Java多线程","slug":"Java多线程","date":"2019-12-27T06:33:33.859Z","updated":"2019-12-27T06:33:33.859Z","comments":true,"path":"2019/12/27/Java多线程/","link":"","permalink":"https://linxd1999.github.io/2019/12/27/Java多线程/","excerpt":"","text":"一.基本概念1.程序，进程，线程 程序：用某种语言编写的一组指令集合，一段静态的代码 进程：程序的一次执行过程，动态过程，存在生命周期。进程是资源分配的单位，系统为每个进程分配不同的内存区域 线程：进程可细分为线程，线程是程序内部一条执行路径。线程是资源分配的最小单位。一个进程中的多个线程共享内存单元和堆，可以访问相同变量和对象，每个线程拥有独立的运行栈和程序计数器pc，切换开销小 多线程：一个进程在同一时间并行执行多个线程。多个线程操作共享资源有安全隐患 2.单核CPU，多核CPU 单核CPU：一个时间单元内，只能执行一个线程的任务 多核CPU：可以真正实现多线程 3.并行，并发 并行：多个CPU同时执行多个任务 并发：一个CPU同时执行多个任务(资源调度) 4.多线程优势 提高程序响应能力，对图形化界面更直观，用户体验好 提高CPU利用率 改善程序结构，有利于后期维护修改 二.线程创建1.Thread类方法 start()：启动当前线程；调用当前线程的run() run()：通常需要重写此方法，将创建线程要执行的操作声明在此方法中 currentThread()：静态方法，返回当前代码的线程 getName()：获取当前线程的名字 setName()：设置当前线程的名字 yield()：释放当前CPU的执行权 join()：调用此函数的线程被阻塞 stop()：已过时，强制结束当前线程 sleep(long millitime)：让当前线程睡眠指定时间，在睡眠期间，线程是阻塞状态 isAlive()：判断线程是否死亡 2.线程优先级 优先级 MAX_PRIORITY：10 MIN_PRIORITY：1 NORM_PRIORITY：5 设置和获取优先级 getPriority()：获取线程优先级 setPriority()：设置线程的优先级 高优先级的线程要抢占低优先级cpu的执行权。但这只是基于概率来说的，高优先级的线程高概率的情况下被执行，并不意味着只有高优先级的线程执行完以后，低优先级的线程才执行 3.继承Thread类 创建一个继承自Thread类的子类 重写Thread类的run()，将此线程执行的操作声明在run()中 创建Thread类子类的对象 通过此对象调用start()：启动当前线程，调用当前线程的run 不能直接通过调用run()启动线程 同一个线程不能启动两次，会报illegalThreadStateException异常。需要重新创建一个新的线程对象 4.实现Runnable接口 创建一个实现了Runnable接口的类 实现Runnable接口中的抽象方法run() 创建实现类的对象 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象 123![ThreadState](D:\\blog\\source\\_posts\\Java多线程\\ThreadState.png)public Thread(Runnable target) &#123; this(null, target, \"Thread-\" + nextThreadNum(), 0);&#125; 通过Thread类的对象调用start()，调用当前线程的run(调用Runnable类型的target的run()) 开发中优先选择Runnable接口创建多线程，因为实现方式没有类的单继承性的局限性，实现的方式更适合处理多个线程有共享数据的情况。 联系：public class Thread implements Runnable 相同点：两种方式都需要重写run()，将线程要执行的逻辑声明在run()中 5.实现Callable接口 创建一个实现了Callable的实现类 实现call方法，将此线程需要的操作声明在call()中 创建Callable实现类对象 将Callable实现类对象传递到FutureTask构造器中，创建FutureTask对象 将FutureTask对象传递到Thread构造器中，创建Thread对象并start 获取Callable接口中call()返回值：FutureTask对象的get()就是call()的返回值 1234567public Object call() throws Exception&#123; //线程操作代码&#125;NumThread numThread = new NumThread(); FutureTask futureTask = new FutureTask(numThread); Thread thread = new Thread(futureTask); Callable比Runnable强大 call()可以有返回值 call()可以抛出异常，被外面的操作捕获，获取异常信息 Callable支持泛型 6.线程池 提高响应速度(减少创建新线程的时间) 降低资源消耗(重复利用线程池中的线程，不需要每次都创建) 便于管理线程 三.线程的生命周期1.线程状态 定义于Thread.State 新建：线程对象声明并创建 就绪：新建的线程start()后，进入队列等待CPU时间片，但是还没分配到资源 运行：就绪的进程被调度，获得CPU资源，run()定义了线程的操作 阻塞：被人为挂起或执行输入输出操作，让出CPU并临时终止自己的执行 死亡：完成工作或强制终止或异常而导致线程结束 2.状态转换图 四.线程同步1.卖票问题 三个窗口同时卖票，直到票被卖完 问题：卖票过程中，出现了重票、错票(出现了线程安全问题) 问题出现的原因：当某个线程操作车票的过程中，尚未操作完成，其他线程参与进来，也操作车票的售卖 解决：当一个线程在操作共享变量时，即使线程被阻塞，其他线程也必须等待该线程操作完成之后才能进行操作 同步机制解决线程安全问题 同步代码块 123synchronized(锁)&#123; //需要被同步的代码&#125; 任何一个类的对象都可以充当锁，但多个线程必须共用一把锁 在实现Runnable接口创建多线程的方式中，可以考虑用this充当同步监视器 同步方法 1private synchronized void show() 同步方法仍然涉及同步监视器，但不需要显示声明 非静态的同步方法：同步监视器为this 静态的同步方法：同步监视器为当前类本身 Lock锁 12345678ReentrantLock lock = new ReentrantLock();//声明//某个函数体内lock.lock();try&#123; //线程安全代码&#125;finally&#123; lock.unlock();&#125; JDK5.0新增，可以显式使用和释放锁，而synchronized是在代码块执行完后自动释放锁 同步可以解决线程安全问题，但同步的代码块只能有一个线程参与，其他线程等待，相当于一个单线程的过程，效率低(局限性) 2.死锁 死锁：不同线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁 出现死锁后，不会抛出异常，不会出现提示，只是所有线程都处于阻塞状态，无法继续进行下去 12345678910111213141516171819202122232425262728293031323334353637383940414243StringBuffer s1 = new StringBuffer();StringBuffer s2 = new StringBuffer(); new Thread()&#123; @Override public void run() &#123; synchronized (s1)&#123; s1.append(\"a\"); s2.append(\"1\"); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (s2)&#123; s1.append(\"b\"); s2.append(\"2\"); System.out.println(s1); System.out.println(s2); &#125; &#125; &#125; &#125;.start(); new Thread(new Runnable() &#123; @Override public void run() &#123; synchronized (s2)&#123; s1.append(\"c\"); s2.append(\"3\"); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (s1)&#123; s1.append(\"d\"); s2.append(\"4\"); System.out.println(s1); System.out.println(s2); &#125; &#125; &#125; &#125;).start(); 五.线程通信 涉及方法 wait()：当前线程进入阻塞状态，释放同步监视器 notify()：唤醒wait的一个线程，如果有多个线程在等待，唤醒优先级高的线程 notifyAll()：唤醒所有wait()的线程 wait()，notify()，notifyAll()这三个方法必须使用在同步代码块和同步方法中 wait()，notify()，notifyAll()这三个方法的调用者必须是同步代码块或者同步方法中的同步监视器，否则会抛出illegalMonitorStateException异常 wait()，notify()，notifyAll()这三个方法都定义在java.lang.Object类中 sleep()和wait()的异同 相同点 两者都会使当前线程阻塞 不同点 声明位置不同：Thread类声明sleep()，Object类声明wait() 调用要求不同：sleep任意场景可调用，wait()必须在同步代码块或者同步方法中 关于是否释放锁：如果两个方法都使用在同步代码块和同步方法中，sleep()不会释放锁，wait()会释放锁 1.生产者与消费者12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182class Clerk&#123; private int productCount = 0; public synchronized void produceProduct() &#123; if (productCount&lt;20)&#123; productCount++; System.out.println(Thread.currentThread().getName() + \"开始生产第\" + productCount + \"个产品\"); notify(); &#125;else &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public synchronized void customerProduct() &#123; if(productCount&gt;0)&#123; System.out.println(Thread.currentThread().getName() + \"开始消费第\" + productCount + \"个产品\"); productCount--; notify(); &#125;else &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;class Producer extends Thread&#123; private Clerk clerk; public Producer(Clerk clerk)&#123; this.clerk = clerk; &#125; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + \"开始生产产品......\"); while(true)&#123; try &#123; sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; clerk.produceProduct(); &#125; &#125;&#125;class Customer extends Thread&#123; private Clerk clerk; public Customer(Clerk clerk)&#123; this.clerk = clerk; &#125; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + \"开始消费产品......\"); while(true)&#123; try &#123; sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; clerk.customerProduct(); &#125; &#125;&#125;public class ProductTest &#123; public static void main(String[] args) &#123; Clerk clerk = new Clerk(); Producer p1 = new Producer(clerk); p1.setName(\"生产者1:\"); Customer c1 = new Customer(clerk); c1.setName(\"消费者1:\"); Customer c2 = new Customer(clerk); c2.setName(\"消费者2:\"); p1.start(); c1.start(); c2.start(); &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://linxd1999.github.io/tags/Java/"}]},{"title":"JavaScript基础","slug":"JavaScript基础","date":"2019-12-27T06:33:33.843Z","updated":"2019-12-27T06:33:33.843Z","comments":true,"path":"2019/12/27/JavaScript基础/","link":"","permalink":"https://linxd1999.github.io/2019/12/27/JavaScript基础/","excerpt":"","text":"一.JS基本概念1.JS是什么 JS是一门运行在浏览器端的脚本语言，负责页面中的行为 2.JS编写的位置 标签的指定属性中 12&lt;button onclick=\"alert('hello');\"&gt;我是按钮&lt;/button&gt;&lt;a href=\"javascript:alert('aaa');\"&gt;超链接&lt;/a&gt; script标签中 123&lt;script type=\"text/javascript\"&gt; //编写js代码&lt;/script&gt; 外部js文件中，通过script标签将其引入，script标签一旦引入外部文件了，就不能编写代码了。如果需要就新创建一个script标签 1&lt;script type=\"text/javascript\" src=\"文件路径\"&gt;&lt;/script&gt; 二.基本语法1.输出语句 alert(“要输出的内容”)：浏览器窗口弹出警告框 document.write(“要输出的内容”)：写入body标签中，并在页面中显示 console.log(“要输出的内容”)：写到开发者工具的控制台中 2.注释，变量，标识符 注释：单行注释//，多行注释/**/ 严格区分大小写 每条语句以分号结尾，不加会耗费系统资源自动加上 自动忽略空格和换行 字面量：一些已经固定的值，数字，字符串，true等等，字面量不可改变，不方便，一般不使用 变量：用var声明，可用来保存字面量，并且可保存任意的字面量 标识符：可以含有字母，数字，下划线，$，不能以数字开头 3.数据类型 基本数据类型（String，Number，Boolean，Null，Undefined），引用数据类型（Object） String：单引号或双引号表示，注意引号匹配，\\为转义字符 Number：所有整数和浮点数，Number.MAX_VALUE为最大值，值超过最大值类型为Infinity，负数相反。NaN为非法数字 Boolean：逻辑判断 Null：空对象，typeof返回object Undefined：声明但没有赋值的变量 Object：对象类型 基本数据类型和引用数据类型关系 JS变量都保存到栈内存中，基本数据类型的值直接在栈内存中存储，值与值之间相互独立存在，修改一个变量不会影响其他的变量 对象保存到堆内存中，每创建一个新的对象，就会在堆内存中开辟一个新的空间，而变量中保存的是对象的内存地址(引用)。如果两个变量保存的是同一个对象的引用时，当通过一个变量修改属性时，另一个也会受影响 当比较两个基本数据类型时，比较数据值；当比较两个引用数据类型的值时，比较内存地址 4.类型转换 转换为String (强制类型转换)调用被转换数据类型的toString()方法，Null和Undefined没有这个方法 (强制类型转换)调用String()函数 (隐式)任意数据类型+” “ 转换为Number (强制类型转换)调用Number()函数，字符串转数字(非法数字-&gt;NaN，空串或空格串-&gt;0)，boolean转数字(true1，false0)，空值转数字(Null-&gt;0)，Undefined转数字(Undefined-&gt;NaN) (强制类型转换)调用parseInt()或者parseFloat()，专门用来处理字符串，可将有效的整数位或小数位提取出来 (隐式)使用一元运算符+来隐式转换 转换为Boolean (强制类型转换)调用Boolean函数，字符串转Boolean(除了空串其他全是true)，数值转Boolean(除了0和NaN其他全是true)，Null、undefined转Boolean(都是false)，object转Boolean(都是true) (隐式)两次非运算!! 5.运算符 typeof运算符：typeof 变量(返回一个用于描述的类型的字符串) 算术运算符：除了加法以外对非Number值进行运算，先转换为Number，加法遇到字符串会拼串，任何值和字符串做加法，都会先转换为字符串 逻辑运算符 &amp;&amp;：短路运算，第一个值为false，返回第一个值；第一个值为true，返回第二个值 ||：短路运算，第一个值为true，返回第一个值；第一个值为false，返回第二个值 关系运算符 对非数值的情况比较，会将其转换为数字然后比较，Null转换为0，字母字符串转换为NaN 符号两侧都是字符串，比较第一位字符的Unicode NaN跟任何值比较都是false，也不与任何值相等 undefined衍生自null，所以两者相等 ===：全等运算符，和相等类似，但类型不同直接返回false !==：不全等运算符，和不等类似，但类型不同直接返回true 6.Unicode编码 在字符串中用转义字符输入Unicode编码(\\u四位编码) 在网页中使用Unicode编码(&amp;#十进制编码) 7.对象 对象是引用数据类型 分类 内建对象：ES标准定义的对象，在任何ES实现中都可以使用，如Math，Number，String，Boolean等等 宿主对象：由JS运行时环境提供的对象，主要是浏览器提供的对象，如BOM，DOM 自建对象：开发人员自己创建的对象 创建对象：var obj = new Object(); or var obj = {属性名:属性值 , 属性名:属性值 ……}(对象字面量的属性名可加引号也可以不加，建议不加，使用特殊名字才要加引号) 添加属性：对象.属性名 = 属性值 or 对象[“属性名”] = 属性值 读取属性：对象.属性名 or 对象[“属性名”]，[ ]中可以使用变量 删除属性：delete 对象.属性名 in运算符：检查一个对象中是否含有指定属性，”属性名” in 对象，返回Boolean 8.函数 函数也是一个对象，具有对象的功能 创建函数 function 函数名([形参1,形参2…形参N]){语句…} var 函数名 = function([形参1,形参2…形参N]){语句…} 调用函数：函数名(); 调用函数时JS解析器不会检查实参的类型和个数，可以传递任意类型的值 实参数量大于形参，多余实参不会赋值 实参数量小于形参，剩余的形参会被赋值为undefined return可以返回任意类型的值，基本函数类型，对象，函数等。不显式声明返回值会返回undefined 立即执行函数：一般只调用一次 123(function fun(形参)&#123; //函数语句...&#125;)(实参); 9.方法 函数也可以作为对象的属性 方法：函数作为对象的属性保存，调用这个函数就被称为调用对象的方法 只是名称上的区分，没有本质的区别 对象.方法名(); 函数名(); for-in循环：查看一个对象内部的属性 123for(var n in 对象名)&#123; console.log(对象名[n]);&#125; 10.作用域 全局作用域：直接编写在script标签中的JS代码，都在全局作用域中。全局作用域在页面打开时被创建，在页面关闭时被销毁 全局作用域中有个全局对象window，它代表一个浏览器的窗口，由浏览器自动创建 在全局作用域中的创建的变量作为window对象的属性保存，创建的函数作为window对象的方法保存 全局作用域中的变量都是全局变量，在页面的任何部分都可以访问的到 函数作用域： 变量声明提前：使用var关键字声明的变量，会在所有代码执行之前被声明(不会赋值) 函数声明提前：使用函数声明形式创建的函数function 函数(){ }会在所有代码执行之前被创建","categories":[],"tags":[{"name":"Front-End","slug":"Front-End","permalink":"https://linxd1999.github.io/tags/Front-End/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://linxd1999.github.io/tags/JavaScript/"}]},{"title":"","slug":"HTML","date":"2019-12-27T06:33:33.812Z","updated":"2019-12-27T06:33:33.812Z","comments":true,"path":"2019/12/27/HTML/","link":"","permalink":"https://linxd1999.github.io/2019/12/27/HTML/","excerpt":"","text":"HTML链接 a标签： 文本链接、图片链接 属性： href：指向另一个文档的链接 name：创建文档内的链接（锚点链接：指向同一个页面内另一处文本段落的链接） img标签属性： alt：替换文本属性 width：宽(px) height：高(px) HTML表格 table标签： 属性： 边框：border 内间距：cellpadding 侧边距：cellspacing 背景颜色：bgcolor 背景图片：background ：单元格 ：表格行 HTML列表 无序列表：使用标签、 属性：(type)disc、circle、square 有序列表：使用标签、 属性：(type)A、a、I、i 嵌套列表：使用标签、、 自定义列表：、、 HTML块 块元素：显示时以新行开始 如、、 内联元素：通常不从新行开始 如、、 div元素：组合html元素的容器，为大块内容提供结构和背景，其中所含元素的特性由div标签的属性来控制 span元素：内联元素，可做文本容器，一般用于改部分文本的样式 div,section,article元素 这三个都是针对一块区域做布局的标签 语义逐渐增强，可嵌套 div本身无语义，用作布局及css样式化 section用作一段有专题性的内容， 里面基本上会带有标题 article用作一段独立的，完整的内容块 nav元素 页面导航的链接组 传统导航条，侧边栏导航，页内导航，翻页操作","categories":[],"tags":[]},{"title":"Hexo博客框架+GitHub部署","slug":"Hexo博客框架+GitHub部署","date":"2019-12-27T06:33:33.812Z","updated":"2019-12-27T06:33:33.812Z","comments":true,"path":"2019/12/27/Hexo博客框架+GitHub部署/","link":"","permalink":"https://linxd1999.github.io/2019/12/27/Hexo博客框架+GitHub部署/","excerpt":"特别感谢up主CodeSheep的视频教程, 原视频请点击Step1： 安装Node.jsNode.js官网下载: https://nodejs.org/en/download/ Step2： 安装GitGit是一个开源的分布式版本控制系统，是为了帮助管理Linux内核开发而开发的版本控制软件。 Git官网下载: https://www.git-scm.com/download/ 安装完之后鼠标右击会出现Git Bash Here， 这就相当于Linux终端，我们等会对博客的操作也都是在这里完成。","text":"特别感谢up主CodeSheep的视频教程, 原视频请点击Step1： 安装Node.jsNode.js官网下载: https://nodejs.org/en/download/ Step2： 安装GitGit是一个开源的分布式版本控制系统，是为了帮助管理Linux内核开发而开发的版本控制软件。 Git官网下载: https://www.git-scm.com/download/ 安装完之后鼠标右击会出现Git Bash Here， 这就相当于Linux终端，我们等会对博客的操作也都是在这里完成。 一些常用的Linux命令行操作： cd ：进入目录 cd ..：返回上一级目录 cd../..：返回上两级目录 pwd：显示当前路径 ls -l：显示当前路径下文件的详细信息 Step3： 安装HexoHexo是一个快速，简洁，高效的博客框架。Hexo使用Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用华丽的主题生成静态网页。 随便在一个盘下新建文件夹，用来操作博客用，后面我都用Blog来表示这个文件夹。 进入Blog文件夹，右键Git Bash Here，首先测试node和npm的版本。 输入命令： 然后安装一个cnpm提高下载速度： npm install -g cnpm –registry=https://registry.npm.taobao.org 测试cnpm： 然后安装Hexo： cnpm install -g hexo-cli 验证是否安装成功 hexo -v 安装成功！ 然后在根目录下执行： hexo init 这是建立整个项目，若Blog文件夹下出现了很多文件则说明成功了。 Step4：运行测试 hexo clean 清理缓存文件 hexo g 生成文件 hexo s 运行本地服务器 hexo d 部署到远端服务器 先在根目录下运行hexo s 然后打开浏览器，输入localhost:4000，出现以下界面 至此，本地环境已经搭建好了。 Step5：部署到Github上登录Github，创建一个新的仓库new repository，仓库名称为你的Github ID.github.io（必须是这这样写） 然后在根目录下安装一个Git部署插件 cnpm install –save hexo-deployer-git 在根目录下的_config.yml文件下修改一些配置 repo把打开仓库看到的那个git结尾的复制进来就好。 最后部署到远端：hexo d 之后会出现一些验证，照着提示做就可以了。 推送到远端成功后，在浏览器输入你的Github ID.github.io就可以访问博客了。","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://linxd1999.github.io/tags/Hexo/"}]},{"title":"","slug":"Collection集合","date":"2019-12-27T06:33:33.781Z","updated":"2019-12-27T06:33:33.781Z","comments":true,"path":"2019/12/27/Collection集合/","link":"","permalink":"https://linxd1999.github.io/2019/12/27/Collection集合/","excerpt":"","text":"Collection集合 集合中只能保存对象的引用变量 List子接口：有序，可重复集合(ArrayList、LinkedList、Vector) Set子接口：无序，不可重复集合(HashSet、LinkedHashSet、TreeSet) Queue子接口：先进先出队列 Lambda表达式遍历集合 Connection接口继承了Iterable接口 Java8新增了一个forEach(Consumer action)方法，参数是消费者(函数式接口) 程序将元素依次传给Consumer的accept()，该方法是接口中唯一的抽象方法 12345List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(\"hello\");list.add(\"world\");list.add(\"java\");list.forEach(obj-&gt;System.out.println(obj)); 类似，Iterator的forEachRemaining(Consumer action)同样可以使用lambda表达式遍历迭代器 1it.forEachRemaining(obj-&gt;System.out.println(obj)); List集合 特点：有序、可重复 新增方法： 12345678910111213List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(\"hello\");list.add(\"world\");list.add(\"java\");//在指定位置添加指定元素list.add(1, \"a\");//删除指定位置元素，返回被删除的元素System.out.println(list.remove(2));//修改指定位置的元素，返回被修改的元素System.out.println(list.set(2, \"javase\"));//返回指定索引处的元素System.out.println(list.get(2));System.out.println(list); 并发修改异常(ConcurrentModificationException) 产生原因：迭代器遍历过程中，通过集合对象修改了集合中元素的长度导致的迭代器获取元素中预期修改值和实际修改值不一致 解决：用for循环替代迭代遍历，用get()获取元素 ListIterator List特有的迭代器 可从任一方向遍历集合 新增add()方法，且底层经过优化，在迭代遍历中用迭代器增加集合内的元素不会抛出并发修改异常。 1234while(it.hasPrevious()) &#123; String s = (String)it.previous(); System.out.println(s);&#125; 增强for循环实际上还是Iterator，迭代时也不能修改元素长度 LinkedList集合 特有方法： 123456public void addFirst(E e)public void addLast(E e)public E getFirst()public E getLast()public E removeFirst()public E removeLast() Set集合 特点：无序，不可重复 没有带索引的方法，不能用普通for循环遍历 哈希值：JDK根据对象的地址或者字符串或者数字算出来的int值 同一个对象多次调用hashCode()方法返回相同哈希值 默认情况下，不同对象的哈希值不同，可通过重写hashCode()方法，可以实现让不同对象的哈希值相同 HashSet集合 底层数据结构是HashMap，由数组和链表构成 存取顺序不做保证 保证元素唯一性：存入元素和以前元素比较哈希值 如果哈希值不同，继续执行，把元素添加入集合 如果哈希值相同，调用equals()方法比较 返回false，继续执行，把元素添加到集合 返回true，说明元素重复，不存储 要保证元素唯一性，需要重写hashCode()和equals() LinkedHashSet 哈希表和链表构成，元素有次序 元素不可重复 TreeSet 元素会按照一定的规则排序，取决于构造方法 TreeSet()：自然排序 TreeSet(Comparator comparator)：根据指定的比较器进行排序 自然排序Comparable 元素所属类实现Comparable接口，重写compareTo(T o)方法 重写方法必须注意按照要求的主要和次要条件来写 compareTo()方法有this，this在前面表示升序 123456789101112131415161718192021222324252627282930313233343536373839import java.util.TreeSet;public class TreeSetDemo &#123; public static void main(String[] args) &#123; TreeSet&lt;Student&gt; ts = new TreeSet&lt;&gt;(); Student s1 = new Student(\"a\",29); Student s2 = new Student(\"c\",28); Student s3 = new Student(\"d\",30); Student s4 = new Student(\"b\",33); Student s5 = new Student(\"c\",33); ts.add(s1); ts.add(s2); ts.add(s3); ts.add(s4); ts.add(s5); ts.forEach(obj-&gt;System.out.println(obj.getName()+\" \"+obj.getAge())); &#125;&#125;class Student implements Comparable&lt;Student&gt;&#123; private String name; private int age; public Student(String name,int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; @Override public int compareTo(Student o) &#123; int num = this.age-o.age; int num2 = num==0 ? this.name.compareTo(o.name) : num; return num2; &#125;&#125; 比较器排序Comparator 重写Comparator的compare(T o1,T o2)方法 123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.*;public class TreeSetDemo &#123; public static void main(String[] args) &#123; TreeSet&lt;Student&gt; ts = new TreeSet&lt;&gt;(new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; int num = o1.getAge()-o2.getAge(); int num2 = num==0 ? o1.getName().compareTo(o2.getName()) : num; return num2; &#125; &#125;); Student s1 = new Student(\"a\",29); Student s2 = new Student(\"c\",28); Student s3 = new Student(\"d\",30); Student s4 = new Student(\"b\",33); Student s5 = new Student(\"c\",33); ts.add(s1); ts.add(s2); ts.add(s3); ts.add(s4); ts.add(s5); ts.forEach(obj-&gt;System.out.println(obj.getName()+\" \"+obj.getAge())); &#125;&#125;class Student&#123; private String name; private int age; public Student(String name,int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125;&#125; Map集合 将键映射到值的对象，不能包含重复键，键可以映射最多一个值 添加元素时，如果键一样，值会被覆盖","categories":[],"tags":[]},{"title":"Css","slug":"CSS","date":"2019-12-27T06:33:33.781Z","updated":"2019-12-27T06:33:33.781Z","comments":true,"path":"2019/12/27/CSS/","link":"","permalink":"https://linxd1999.github.io/2019/12/27/CSS/","excerpt":"","text":"一.CSS 层叠样式表(Cascading Style Sheets) 可为网页的多层结构创建样式表，从而装饰网页 层叠意味着网页是分层结构，层次高的覆盖层次低的 二.样式表1.内联样式表 可将css样式写到元素的style属性中，只对当前元素起作用，不方便复用和后期维护 2.内部样式表 将style标签写到head标签中，可改变该文件中的样式，但不方便应用于多个文件 3.外部样式表 将样式表写到一个单独的.css文件中，如果某个文件要使用css样式，需要link标签引用 1&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"&gt; 完全使结构和表现分离，使样式表可在不同页面中使用，最大限度的复用了样式表，可以利用浏览器的缓存，加快用户访问速度，提高用户体验。 开发中最推荐使用外部css文件 在CSS中，祖先元素上的样式，会被后代元素所继承，利用继承可把一些基本的样式设置给祖先元素，这样所有的后代元素都将会自动继承这些样式 但不是所有样式都会被继承，背景相关，边框相关，定位相关的样式都不会被继承，否则会带来样式混乱的后果 三.语法1.注释 /**/ 2.选择器 选中页面中指定的元素，并且将声明块中样式应用到选择器对应的元素上 1.元素选择器 可以选择某种单独的元素设置样式 2.id选择器 对某个元素设置id属性，可以做到选中某种元素中带id的元素，用#标识 不建议用复合选择器 3.类选择器 对某个元素设置class属性，可以把几个元素分为一组来设置样式，用.标识 4.并集选择器 对几个选择器进行合并，可以同时操作更多不同的标签，用” , “分开 5.交集选择器 可以选中同时满足多个选择器的元素设置样式 6.通配选择器 可以选中页面内的所有元素，用” * “标识 7.后代选择器 语法：祖先元素 后代元素{ } 可选中某个特定祖先元素的某后代元素 8.子元素选择器 语法：父元素&gt;子元素 可选中指定父元素的子元素 9.伪类选择器 用来表示元素的一种特殊的状态 例如：访问过的超链接，获取焦点的文本框 链接样式：a:link(正常链接)，a:visited(访问过的链接)，a:hovor(鼠标滑过的链接)，a:active(正在点击的链接) hover和active也可以为其他元素设置样式 其他伪类选择器：input:focus(获取焦点)，p::selection(选中文本) 123456789101112131415a:link&#123; color: red; &#125; a:visited&#123; color: yellow; &#125; a:hover&#123; color: aqua; &#125; a:active&#123; color: black; &#125; p:active&#123; color: red; &#125; link，visited，hover，active优先级相同，但有顺序的区别。hover如果放active后面，则active被覆盖而失效，link，visited也必须放在hover，active前面，原因同理。 10.伪元素 CSS 在渲染文档的时候，伪元素可以通过 css 给 HTML 添加一个元素（叫标签也行），这个元素在文档树中是找不到的。 常见的有 :before(表示元素最前边的部分)，:after(表示元素最后边的部分)，:first-letter(选中第一个字母)，:first-line(选中元素的第一行) 11.属性选择器 title属性：这个标签可以给任何标签指定，当鼠标移到元素上时，title属性的值将会作为提示文字显示 作用：可以根据元素中的属性或属性值来选取指定元素 语法： [属性名] 选取含有指定属性的元素 [属性名=”属性值”] 选取含有指定属性值的属性 [属性名^=”属性值”] 选取以属性值以指定内容开头的元素 [属性名$=”属性值”] 选取以属性值以指定内容结尾的元素 [属性名*=”属性值”] 选取以属性值包含指定内容的元素 12.子元素的伪类 :first-child：选中第一个子元素 :last-child：选中最后一个子元素 :nth-child：选中任意位置的子元素，该选择器后面可以指定一个参数，指定要选中第几个子元素 even表示偶数位置的子元素 odd表示奇数位置的子元素 first-of-type，last-of-type，nth-of-type和上面三个非常类似，只不过child是在所有子元素里排列，type是在当前类型的子元素中排列 13.兄弟元素选择器 span+p：选中span后一个紧挨着的p元素 span~p：选中span后所有的p元素 14.否定伪类 可以从已选中的元素中剔除某些元素 语法：:not(选择器) 15.选择器的优先级 不同选择器选中同一个元素并且设置相同样式时，优先级高的选择器优先设置样式 规则： 内联样式：优先级1000 id选择器：优先级100 类和伪类：优先级10 元素选择器：优先级1 通配选择器：优先级0 继承的样式：无优先级 选择器中包含多个选择器时(交集选择器)，优先级相加再比较，但是和不会超过他的最大数量级 如果选择器优先级一样，则使用靠后的样式(覆盖) 并集选择器的优先级单独计算 样式最后可添加 !important，此时该样式的优先级会超越内联样式，但尽量避免使用 3.声明块 声明块紧跟选择器后边，用一对{}括起来 实际上就是名值对结构，一个声明块中可写多个声明，声明之间用;隔开，名值之间用:隔开 四.块元素和内联元素1.块元素 会独占一行的元素，无论内容多少，都会占一行 块元素主要用来对页面做布局 div元素：没有任何语义，是一个纯粹的块元素，不会为里面的内容设置任何默认样式 div元素主要用来对页面进行布局 a元素可以包含任何元素，但不能包含本身 p元素不可以包含任何其他的块元素 2.内联元素(行内元素) 不会占用一整行，只会占用自身大小 内联元素主要用来选中文本设置样式 span元素：本身没有任何语义，用来选中文字来设置样式 一般用块元素包含内联元素 五.文本1.文本标签 cite标签：参考的内容，如书名，歌名，话剧名，电影名等 small标签：内容比父元素中的文字小一些 p标签：短引用，内联引用 blockquote：长引用，块引用 sup标签：设置上标(superscript) sub标签：设置下标(subscript) del标签：删除的内容(划掉) ins标签：插入的内容(下划线) code标签：专门表示代码 pre标签：预格式标签，会将代码中的格式保存，不会忽略空格(一般结合pre和code表示一段代码) ul标签：无序列表 ol标签：有序列表 li标签：列表项 有序无序列表都可以改type属性来修改项目符号，但一般不使用，可用为li设置背景图片的方法来设置 ul，ol，li都是块元素 可互相嵌套 dl标签：定义列表，子标签dt：被定义的内容；dd：对定义内容的描述 2.文本样式 text-transform：设置文本大小写 none：默认值 capitalize：单词首字母大写，通过空格来识别单词 uppercase：所有字母大写 lowercase：所有字母小写 text-decoration：设置文本的修饰 none：默认值 underline：下划线 overline：上划线 line-through：删除线 超链接默认添加下划线，也就是text-decoration默认值为underline letter-spacing：字符间距 word-spacing：单词间距 text-align：设置文本对齐 left：靠左对齐 right：靠右对齐 center：居中对齐 justify：两端对齐(调整文本之间的空格) text-indent：设置首行缩进 指定一个正值时，会自动向右缩进指定的像素；指定一个负值，向左移动指定的像素，可以将一些不想显示的文字隐藏起来。 text-indent: 2em表示首行缩进两个字符，会根据字体大小变化而变化。 六.长度单位 像素px(pixel)：使用最多的单位，一个像素相当于屏幕上的一个小点，但这些像素点是不能被直接看见的。不同显示器的一个像素大小不同，显示效果越好，像素就越小。 百分比%：浏览器会根据父元素的样式来计算该值。好处在于父元素属性值变化时，子元素会随之改变，在创建自适应页面时，常使用百分比作为单位 em：和百分比类似，是相对于当前元素的字体大小来计算的，1em=1font-size(当前元素的字体大小)。使用em时，当字体大小发生改变时，em也会随之改变，当设置字体相关样式时会经常使用em 七.颜色单位 可直接用颜色的单词来表示不同的颜色 可用RGB值来表示不同的颜色 Red，Green，Blue三原色，通过三种颜色的不同浓度来表示不同的颜色 rgb(红色的浓度，绿色的浓度，蓝色的浓度) 颜色的浓度是一个0-255之间的值，255表示最大，0表示没有，也可用百分比 可用十六进制的rgb值来表示颜色，原理同上 语法：#红色绿色蓝色 00表示没有，ff表示255 两位重复数字可简写成一个数字 八.字体 color：字体颜色 font-size：设置的并不是字体大小，在页面中，每个文字都处于一个看不见的框中，font-size实际上设置的是格子的高度。一般情况下文字都要比格小一些，有时候也会比格大。根据字体的不同，显示效果也不同 font-family：指定文字字体 浏览器支持则使用，不支持则使用默认字体 可同时指定多个字体，用逗号分隔，优先使用前面的字体，如果没有或设置不了再尝试下一个 字体分为5大类：serif(衬线字体)，sans-serif(非衬线字体)，monospace(等宽字体)，cursive(草书)，fantasy(虚幻字体)，前两个很长用，一般放设置字体的最后兜底 font-style：可用来设置文字斜体 normal：文字正常 italic：文字斜体显示 oblique：文字倾斜，效果和italic一样，一般用italic font-weight：可显示文字的加粗效果 normal：正常粗细 bold：文字加粗显示 font-variant：设置小型大写字母 normal：正常字体 small-caps：小型大写字母 font：可同时设置字体相关的所有样式，用空格分开 斜体，加粗，小大字母，没有顺序要求，可写可不写，不写使用默认值 文字的大小和字体必须写，而且字体必须是最后一个样式，大小必须是倒数第二个样式 性能较好 九.行高 line-height：间接设置行间距，行间距=行高-字体大小 接收值： 直接接收一个大小 指定一个百分数，会相对字体去计算 接收一个数，则行高会设置字体大小相应的倍数 对于单行文本来说，可以将行高设置成和父元素一致，可以使单行文本在父元素中垂直居中 在font属性中可以指定行高，在字体大小后可以添加 / 行高，来指定行高，该值可选，如果不指定则会使用默认值 12345p&#123; /*前一行不生效，行高被后一行的默认值覆盖*/ line-height: 40px; font: 30px \"微软雅黑\"; &#125; 十.背景 background-image：设置背景图片 语法：background-image：url(“相对路径”) 如果背景图片大于元素，默认会显示图片的左上角 如果背景图片和元素一样大，则会将背景图片全部显示 如果背景图片小于元素，则平铺图片充满元素 一般设置背景图片时都会同时指定一个背景颜色 background-repeat：设置背景图片的重复方式 repeat：默认值，背景图片平铺 no-repeat：背景图片不会重复 repeat-x：背景图片沿水平方向重复 repeat-y：背景图片沿竖直方向重复 background-position：背景图片默认贴着左上角，这个属性可以调整图片在元素中的位置 该属性可以使用top，left，right，bottom，center中的两个值来指定位置 top left：左上，默认 bottom right：右下 缺省值会被指定为center 也可以指定两个偏移量：xpos，ypos，正数向右(下)移动，负数向左(上)移动 background-attachment：设置图片是否随页面一起滚动 scroll：默认值，背景图片会随着窗口滚动 fixed：背景图片会固定在某一个位置，不随页面滚动，一般都是设置body中的大图片；设置在块元素中的图片也不会随页面滚动，但是块元素会随着页面滚动，所以会出现擦黑板一样的效果(背景图片的定位永远相对于浏览器的窗口)，所以不随窗口滚动的图片一般设置给body，而不设置给其他元素。 background：设置所有的背景图片属性 没有顺序和数量的要求 没写的样式就使用默认样式，注意覆盖 十一.CSS-sprite 用不同图片表示一个按钮的不同状态时，第一次切换图片时，会发现有个非常快的闪烁，会造成一次不良的用户体验 产生原因：背景图片是以外部资源的形式加载进网页的，浏览器每加载一个外部资源就需要单独发送一次http请求；外部资源并不是同时加载，浏览器会在资源被使用的时候才去加载外部资源，由于加载图片需要一定的时间，所以在加载和显示的过程中有一段时间，背景图片无法显示，所以才会出现闪烁的情况 解决方法：可以将多张图片整合为一张图片，这样可以几张图片一起加载，就不会产生闪烁的问题了；然后通过background-position来切换要显示的图片位置，这种技术叫做图片整合技术(CSS-sprite，精灵图，雪碧图) 优点 浏览器只要发送一次加载请求就可以同时加载多个图片，提高请求的速度，增加用户体验 多张图片整合成一张，减少图片的总大小，提高请求的速度 十二.表格1.表格标签 使用table标签创建表格 tr创建表格中的一行，在tr中用td创建单元格 th创建表格的头部，有默认加粗和居中的样式，是一种特殊的td rowspan用来设置纵向单元格的合并，colspan用来设置横向单元格的合并 2.表格样式 分别给table和td设置border属性会有一个边框缝隙的效果(table和td之间有缝隙)，可以在table中border-spacing属性设置为0px来解决,但是边框重叠会有一个加粗的视觉效果 border-collapse：collapse(为表格设置合并边框的模式)，设置后border-spacing自动失效 隔行不同效果：tr:nth-child(odd/even) 3.长表格 分为三个部分：thead表头，tbody表格主题，tfoot表格底部 区分表格中不同的部分，都是table的子标签，直接写在table中，tr写在这几个子标签中 tfoot中的内容永远显示在表格底部，thead中的内容永远显示在表格头部 若表格没有写tbody，浏览器会自动生成tbody，并且把所有的tr都放入tbody中。注意：tr不是table的子元素，而是tbody的子元素 通过table &gt; tr无法选中tr，需要tbody &gt; tr 4.clearfix 可以解决高度塌陷，父元素和子元素的垂直外边距不会重叠的双重问题 12345.clearfix:after, .clearfix:before&#123; content: \"\"; display: table; clear: both;&#125; 十三.表单 网页中的表单用来向服务器提交信息，如：搜索框，登录，注册等 action属性：指向一个服务器的地址，表单内容会提交到相应的服务器地址 input标签 type属性为text，创建文本框，value属性指定了文本框的默认显示 type属性为submit，创建提交按钮，value属性指定按钮文字 type属性为reset，创建重置按钮，点击后表单内容恢复默认值 type属性为button，创建单纯的按钮，可用JS绑定事件 希望表单中的数据提交到服务器中，需要在文本框的input中添加name属性，表示提交内容的名字 用户填写的信息会附在url地址后边以查询字符串的形式发送给服务器：url地址?查询字符串(属性名=属性值 &amp; 属性名=属性值) type属性为password，文本框的输入不会明文显示 type属性为radio，单选按钮，通过name属性分组，name值相同为一组，对于这种不需要填写内容的表单项，必须设置value属性来提交给服务器 type属性为checkbox，多选按钮，通过name属性分组，name值相同为一组，对于这种不需要填写内容的表单项，必须设置value属性来提交给服务器 checked属性：设置单选和多选打开后的默认选项，值也为checked placeholder属性：在文本框和文本域中指定水印文字，IE8及以下不支持，需要使用JS select标签：创建下拉列表 option标签：创建列表项 下拉列表的name属性要指定给select，value属性要指定给option option的selected属性：设置下拉列表的默认选项，值也为selected multiple属性：multiple，多选下拉列表 optgroup标签：表单项分组，可以把option项写进optgroup，用label属性分组 textarea标签：多行文本域 button标签：创建按钮，和input的submit效果相同，也可以设置type来指定按钮类型。和input的区别在于button成对出现，而input只有一个标签 label标签：可以通过提示文字选中表单内容，但是需要绑定label中的for属性和input中的id属性，使得两者相同。 fieldset标签：可以划分表单域 legend标签：一般用于fieldset标签中，给每个表单域设置标题 十四.CSS-Hack1.条件hack 条件hack用于让某段语句在指定浏览器中显示，是一段特殊代码，只适用于IE10以下的浏览器 语法： 123&lt;!-- [if 关键词(可选) IE version(可选)]&gt;HTML代码块&lt;![endif]--&gt; 关键词 gt(greater than)：大于 gte(greater than or euqal)：大等于 lt(less than)：小于 lte(less than or equal)：小等于 !：非指定版本 2.属性hack 添加了_的样式只有IE6以下的浏览器认识 _background-color 添加了的样式只有IE7以下的浏览器认识 background-color 样式最后添加\\0，只有IE8以上的浏览器认识 background-color: red\\0 3.选择器hack 在选择器前添加 * html ，则该选择器只有IE6可以识别 hack不到万不得已尽量不使用","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://linxd1999.github.io/tags/CSS/"},{"name":"Front-End","slug":"Front-End","permalink":"https://linxd1999.github.io/tags/Front-End/"}]},{"title":"B树","slug":"B树","date":"2019-12-27T06:33:33.765Z","updated":"2019-12-27T06:33:33.765Z","comments":true,"path":"2019/12/27/B树/","link":"","permalink":"https://linxd1999.github.io/2019/12/27/B树/","excerpt":"","text":"一.B树1.概念 B树：平衡的多路搜索树，多用于文件系统、数据库的实现(也叫B-树) 特点： 一个节点可以存储超过两个元素，可以拥有超过两个子节点 拥有二叉平衡搜索树的一些性质 所有节点高度一致 比较矮 B树和二叉搜索树，在逻辑上等价 多代节点合并，获得一个超级节点 2代合并的超级节点，最多拥有4个子节点(至少是4阶B树) 3代合并的超级节点，最多拥有8个子节点(至少是8阶B树) 2.m阶B树的性质 假设一个节点存储的元素个数为x 根节点：1 ≤ x ≤ m-1 非根节点：ceiling(m/2)-1 ≤ x ≤ m-1 如果有子节点，子节点个数y=x+1 根节点：2 ≤ x ≤ m 非根节点：ceiling(m/2) ≤ x ≤ m 例如m=3，2 ≤ y ≤ 3，称为(2,3)树、2-3树 例如m=4，2 ≤ y ≤ 4，称为(2,4)树、2-3-4树 若m = 2，B树就是平衡二叉搜索树 m阶B树，最多需要log2m代合并 示例： 二.B树的操作1.搜索 先在节点内部从小到大开始搜索元素 命中，搜索结束 未命中，再去对应的子节点中去搜索元素，重复步骤1 2.添加 新添加的元素必定是添加到叶子节点 若叶子节点的元素数量超过m阶B树的元素数量上限(m-1)，发生上溢(overflow) 3.上溢 上溢的节点元素个数必然是m 将上溢节点最中间的元素k向上与父节点合并，[0，k-1]和[k+1，m-1]位置的元素分裂成两个子节点(这两个子节点的元素个数都高于ceiling(m/2)-1) 一次分裂完成后，可能导致父节点上溢。最极端的情况是一直分裂到父节点 4.删除 删除叶子节点：在满足节点元素的个数的前提下直接删除即可 删除非叶子节点 找到前驱或后继元素，覆盖所需删除元素的值 删除前驱或后继元素 非叶子节点的前驱或后继，必定在叶子节点中(实际还是删除叶子节点) 删除节点后，可能发生下溢 5.下溢 下溢：节点元素数量等于ceiling(m/2)-2 如果下溢节点临近的兄弟节点，有至少ceiling(m/2)个元素，可以向其借一个元素 将父节点的元素b插入到下溢节点的0位置(最小位置) 用兄弟节点的元素a(最大的元素)替代父节点的元素b 实质就是旋转 如果下溢节点临近的兄弟节点，只有ceiling(m/2)-1个元素 将父节点的元素b拿下来与左右子节点进行合并 合并后的节点元素个数等于ceiling(m/2)+ceiling(m/2)-2，不超过m-1 这个操作可能会导致父节点下溢，依然按照上述方法解决，下溢现象可能会一直往上传播","categories":[],"tags":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://linxd1999.github.io/tags/DataStructure/"},{"name":"Tree","slug":"Tree","permalink":"https://linxd1999.github.io/tags/Tree/"}]},{"title":"AVL树","slug":"AVL树","date":"2019-12-27T06:33:33.734Z","updated":"2019-12-27T06:33:33.734Z","comments":true,"path":"2019/12/27/AVL树/","link":"","permalink":"https://linxd1999.github.io/2019/12/27/AVL树/","excerpt":"","text":"一.AVL树 AVL树：平衡二叉搜索树 平衡因子：某节点的左右子树的高度差 特点： 每个节点的平衡因子只可能是1,0，-1(绝对值&lt;=1) 搜索，添加，删除的时间复杂度是O(logn) 可继承自BST 需要在节点类里添加height属性 二.添加导致的失衡 最坏情况：所有祖先节点都失衡 父节点，非祖先节点不会失衡 g节点：失衡的高度最小的节点 p节点：g的左右孩子节点中高度较大的节点 n节点：p的左右孩子节点中高度较大的节点 1.LL(右单旋) LL：Left-Left，失衡节点左侧再左侧的节点的子树添加节点导致的失衡 g.left = p.right且p.right = g T2，p，g的parent属性需要维护 更新g，p的高度 1234567private void rotateRight(Node&lt;E&gt; grand)&#123; Node&lt;E&gt; parent = grand.left; Node&lt;E&gt; child = parent.right; grand.left = child; parent.right = grand; afterRotate(grand,parent,child);&#125; 2.RR(左单旋) RR：Right-Right，失衡节点右侧再右侧的节点的子树添加节点导致的失衡 g.right = p.left且p.left = g T1，p，g的parent属性需要维护 更新g，p的高度 12345678private void rotateLeft(Node&lt;E&gt; grand)&#123; Node&lt;E&gt; parent = grand.right; Node&lt;E&gt; child = parent.left; grand.right = parent.left; parent.left = grand; afterRotate(grand,parent,child); &#125; 3.LR(左右双旋) LR：Left-Right，失衡节点左侧再右侧的节点的子树添加节点导致的失衡 先对p做左单旋，再对g做右单旋 4.RL(右左双旋) RL：Right-Left，失衡节点右侧再左侧的节点的子树添加节点导致的失衡 先对p做右单旋，再对g做左单旋 5.更新节点数据 在添加节点后需要更新每个节点的高度，如果添加完节点后平衡，则直接更新；如果添加完节点后失衡，先旋转恢复平衡，然后更新节点高度 12345678910111213@Overrideprotected void afterAdd(Node&lt;E&gt; node) &#123; while ((node = node.parent)!=null)&#123; if (isBalanced(node))&#123; //更新高度 updateHeight(node); &#125;else &#123; //恢复平衡 rebalance(node); break; &#125; &#125;&#125; 123456789101112131415161718192021private void afterRotate(Node&lt;E&gt; grand, Node&lt;E&gt; parent, Node&lt;E&gt; child)&#123; //更新父节点,使parent成为子树的根节点 parent.parent = grand.parent; if (grand.isLeftChild())&#123; grand.parent.left = parent; &#125;else if (grand.isRightChild())&#123; grand.parent.right = parent; &#125;else &#123; //grand根节点 root = parent; &#125; //更新child的parent if (child!=null)&#123; child.parent = grand; &#125; //更新grand的parent grand.parent = parent; //更新高度 updateHeight(grand); updateHeight(parent); &#125; 三.删除导致的失衡 只会导致父节点或祖先节点失衡(只有一个节点失衡) 让父节点恢复平衡之后，可能会导致更高层的祖先节点失衡 1.LL(右单旋) 如果绿色节点不存在，则g的父节点或某个祖先节点可能会因此失衡。而这种失衡可能进一步导致再往上的祖先节点以相同的原因失衡 2.RR(左单旋) 3.LR(左右双旋) 4.RL(右左双旋) 5.核心逻辑123456789101112131415@Override protected void afterRemove(Node&lt;E&gt; node) &#123; //删除逻辑是覆盖，即改变被删除节点父节点的左右指针指向，所以node.parent不会是空 //被删除的节点所占用的内存空间会因为没有对象指向它而被GC回收 while ((node = node.parent)!=null)&#123; if (isBalanced(node))&#123; //更新高度 updateHeight(node); &#125;else &#123; //恢复平衡 //和添加的唯一区别就是调整平衡后不需要break，因为后面还可能有失衡的节点 rebalance(node); &#125; &#125; &#125; 四.时间复杂度 平均时间复杂度 搜索：O(logn) 添加：O(logn)，仅需O(1)次旋转操作 删除：O(logn)，最多需要O(logn)次的旋转操作","categories":[],"tags":[{"name":"DataStructure","slug":"DataStructure","permalink":"https://linxd1999.github.io/tags/DataStructure/"},{"name":"Tree","slug":"Tree","permalink":"https://linxd1999.github.io/tags/Tree/"}]}]}